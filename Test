package com.epay.transaction.dao;


import com.epay.transaction.config.TransactionConfig;
import com.epay.transaction.dto.ErrorLogDto;
import com.epay.transaction.dto.MerchantOrderDto;
import com.epay.transaction.entity.MerchantOrder;
import com.epay.transaction.exceptions.TransactionException;
import com.epay.transaction.externalservice.response.admin.MerchantInfoResponse;
import com.epay.transaction.mapper.MerchantOrderMapper;
import com.epay.transaction.repository.MerchantOrderRepository;
import com.epay.transaction.util.EPayIdentityUtil;
import com.epay.transaction.util.TransactionErrorConstants;
import com.epay.transaction.util.enums.EntityType;
import com.epay.transaction.util.enums.FailureReason;
import com.epay.transaction.util.enums.OrderStatus;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.text.MessageFormat;
import java.util.List;

import static com.epay.transaction.util.EncryptionDecryptionUtil.hashValue;
import static com.epay.transaction.util.TransactionErrorConstants.*;

/**
 * Class Name: OrderDao
 * *
 * Description: MerchantOrderDao class for access order repository
 * *
 * Author: V1012904(Shital suryawanshi)
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * *
 * Version:1.0
 */


@Component
@RequiredArgsConstructor
public class MerchantOrderDao {
    private final LoggerUtility logger = LoggerFactoryUtility.getLogger(this.getClass());
    private final MerchantOrderRepository merchantOrderRepository;
    private final MerchantOrderMapper merchantOrderMapper;
    private final TransactionConfig transactionConfig;
    private final KmsDao kmsDao;
    private final AdminDao adminDao;
    private final ErrorLogDao errorLogDao;

    /**
     * Method name : createMerchantOrder
     * Description : Creates merchant order
     *
     * @param merchantOrderDto an object of MerchantOrderDto
     * @return object of MerchantOrderDto
     */
    @Transactional
    public MerchantOrderDto createMerchantOrder(MerchantOrderDto merchantOrderDto) {
        merchantOrderDto.setStatus(OrderStatus.CREATED);
        merchantOrderDto = saveOrder(merchantOrderDto);
        merchantOrderDto.setOrderHash(hashValue(merchantOrderDto.getMId(), merchantOrderDto.getSbiOrderRefNumber()));
        merchantOrderDto.setTransactionUrl(transactionConfig.getTransactionWebAppBasePath() + merchantOrderDto.getOrderHash());
        merchantOrderDto = saveOrder(merchantOrderDto);
        return merchantOrderDto;
    }

    /**
     * Method name : createMerchantOrder
     * Description : Stores merchant order into database
     *
     * @param merchantOrderDto an object of MerchantOrderDto
     * @return an object of MerchantOrderDto after conversion from entity to DTO.
     */
    public MerchantOrderDto saveOrder(MerchantOrderDto merchantOrderDto) {
        MerchantOrder merchantOrder = merchantOrderMapper.dtoToEntity(merchantOrderDto);
        merchantOrder = merchantOrderRepository.save(merchantOrder);
        logger.info("Save merchantOrder request successfully in DB:{}", merchantOrder);
        return merchantOrderMapper.entityToDto(merchantOrder);
    }

    /**
     * Method name : updateOrderStatus
     * Description : Updates merchant order status into database
     *
     * @param merchantOrderDto merchantOrderDto
     */
    public void updateOrderStatus(MerchantOrderDto merchantOrderDto) {
        MerchantOrder merchantOrder = merchantOrderMapper.dtoToEntity(merchantOrderDto);
        merchantOrderRepository.save(merchantOrder);
        logger.info("Updated order status successfully in DB.");
    }

    public MerchantOrderDto getMerchantOrderByOrderRefAndSbiOrderRefNumber(String orderRefNumber, String sbiOrderRefNumber) {
        MerchantOrder merchantOrder = merchantOrderRepository.findByOrderRefNumberAndSbiOrderRefNumber(orderRefNumber, sbiOrderRefNumber).orElseThrow(() -> {
            errorLogDao.saveErrorLog(ErrorLogDto.builder().mId(EPayIdentityUtil.getUserPrincipal().getMId()).entityType(EntityType.ORDER).failureReason(FailureReason.CUSTOMER).errorCode(NOT_FOUND_ERROR_CODE).errorMessage(MessageFormat.format(NOT_FOUND_ERROR_MESSAGE, MERCHANT_ORDER)).build());
            return new TransactionException(NOT_FOUND_ERROR_CODE, MessageFormat.format(NOT_FOUND_ERROR_MESSAGE, MERCHANT_ORDER));
        });
        return merchantOrderMapper.entityToDto(merchantOrder);
    }

    /**
     * Method name : getOrderByOrderRefNumber
     * Description : Fetch merchant order using orderRefNumber.
     *
     * @param orderRefNumber is a String.
     * @return an object of MerchantOrderDto.
     */
    public MerchantOrderDto getOrderByOrderRefNumber(String orderRefNumber) {
        MerchantOrder merchantOrder = merchantOrderRepository.findByOrderRefNumber(orderRefNumber).orElseThrow(() ->
        {
            errorLogDao.saveErrorLog(ErrorLogDto.builder().mId(EPayIdentityUtil.getUserPrincipal().getMId()).entityType(EntityType.ORDER).failureReason(FailureReason.CUSTOMER).errorCode(NOT_FOUND_ERROR_CODE).errorMessage(MessageFormat.format(NOT_FOUND_ERROR_MESSAGE, MERCHANT_ORDER)).build());
            return new TransactionException(NOT_FOUND_ERROR_CODE, MessageFormat.format(NOT_FOUND_ERROR_MESSAGE, MERCHANT_ORDER));

        });
        logger.info("Get merchantOrder from DB by merchantOrder reference number:{}", merchantOrder);
        return merchantOrderMapper.entityToDto(merchantOrder);
    }

    /**
     * Method name : getValidOrderBySBIOrderRefNumber
     * Description : Fetch valid merchant order using sbiOrderRefNumber.
     *
     * @param sbiOrderRefNumber is a String.
     * @return an object of MerchantOrderDto.
     */
    public MerchantOrderDto getValidOrderBySBIOrderRefNumber(String sbiOrderRefNumber) {
        MerchantOrder merchantOrder = merchantOrderRepository.findBySbiOrderRefNumber(sbiOrderRefNumber).orElseThrow(() ->
        {
            errorLogDao.saveErrorLog(ErrorLogDto.builder().mId(EPayIdentityUtil.getUserPrincipal().getMId()).entityType(EntityType.ORDER).failureReason(FailureReason.CUSTOMER).errorCode(ATTEMPT_EXPIRED_ERROR_CODE).errorMessage(ATTEMPT_EXPIRED_ERROR_MESSAGE + " or MerchantOrder is not valid.").build());
            return new TransactionException(ATTEMPT_EXPIRED_ERROR_CODE, ATTEMPT_EXPIRED_ERROR_MESSAGE + " or MerchantOrder is not valid.");});

        logger.info("Get merchantOrder from DB by active merchantOrder reference number:{}", merchantOrder);
        return merchantOrderMapper.entityToDto(merchantOrder);
    }


    /**
     * Method name : getOrderByOrderHashAndStatus
     * Description : Fetch merchant order by orderHash And orderStatus.
     *
     * @param orderHash   is a String.
     * @param orderStatus is a List of OrderStatus.
     * @return an object of MerchantOrderDto.
     */
    public MerchantOrderDto getOrderByOrderHashAndStatus(String orderHash, List<OrderStatus> orderStatus) {
        MerchantOrder merchantOrder = merchantOrderRepository.findOrderByHashAndStatus(orderHash, orderStatus).orElseThrow(() ->
                {
                    errorLogDao.saveErrorLog(ErrorLogDto.builder().mId(EPayIdentityUtil.getUserPrincipal().getMId()).entityType(EntityType.TOKEN).failureReason(FailureReason.TECHNICAL).errorCode(NOT_FOUND_ERROR_CODE).errorMessage(MessageFormat.format(NOT_FOUND_ERROR_MESSAGE, MERCHANT_ORDER)).build());
                  return   new TransactionException(NOT_FOUND_ERROR_CODE, MessageFormat.format(NOT_FOUND_ERROR_MESSAGE, MERCHANT_ORDER));
                });
        return merchantOrderMapper.entityToDto(merchantOrder);

    }

    /**
     * Method name : existsByOrderRefNumber
     * Description : Validates merchant order using orderRefNumber.
     *
     * @param orderRefNumber is a String.
     * @return boolean value.
     */
    public boolean existsByOrderRefNumber(String orderRefNumber) {
        return merchantOrderRepository.existsByOrderRefNumber(orderRefNumber);
    }

    /**
     * Method name : getActiveOrderByOrderHash
     * Description : Fetch merchant order using orderHash.
     *
     * @param orderHash is a String.
     * @return an object of MerchantOrderDto
     */
    public MerchantOrderDto getActiveOrderByOrderHash(String orderHash) {
        logger.info("Request for active MerchantOrder using orderHash from MerchantOrder Database");
        MerchantOrder merchantOrder = merchantOrderRepository.findByOrderHashAndStatusAndExpiryGreaterThan(orderHash, OrderStatus.CREATED, System.currentTimeMillis()).orElseThrow(() -> new TransactionException(NOT_FOUND_ERROR_CODE, MessageFormat.format(NOT_FOUND_ERROR_MESSAGE, VALID_MERCHANT_ORDER)));
        logger.info("Getting Active MerchantOrder using orderHash from MerchantOrder Database");
        return merchantOrderMapper.entityToDto(merchantOrder);
    }

    /**
     * Method name : getMerchantMek
     * Description : Fetches MEK from Key management Service
     *
     * @return a String
     */
    public String getMerchantMek() {
        return kmsDao.getMerchantMekKey();
    }

    /**
     * Method name : getMerchantMek
     * Description : Fetches Merchant Details using mId
     *
     * @param mId is a String.
     * @return an object of MerchantInfoResponse
     */
    public MerchantInfoResponse getMerchantByMId(String mId) {
        return adminDao.getMerchantByMId(mId);
    }

    /**
     * This method is used to check the PAID order Status for orderRefNumber
     *
     * @param orderRefNumber String
     * @return boolean
     */
    public boolean isOrderStatusPaid(String orderRefNumber) {
        return merchantOrderRepository.existsByOrderRefNumberAndStatus(orderRefNumber,OrderStatus.PAID);
    }

    /**
     * This method is used to get the Sbi order reference number count against order reference number.
     *
     * @param orderRefNumber String
     * @return int
     */
    public long getSbiOrderRefNumberCountByOrderRefNumber(String orderRefNumber) {
        logger.info("Finding SbiRefNumber count by orderRefNumber : {}", orderRefNumber);
        return merchantOrderRepository.countSbiOrderRefNumberByOrderRefNumber(orderRefNumber);
    }
}

package com.epay.transaction.dao;

import com.epay.transaction.dto.ErrorLogDto;
import com.epay.transaction.entity.ErrorLog;
import com.epay.transaction.mapper.ErrorMapper;
import com.epay.transaction.repository.ErrorLogRepository;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Repository;


/**
 * Class Name: public class ErrorLogDao
 * *
 * Description: CRUD for Error log.
 * *
 * Author: Gireesh M
 * <p>
 * Copyright (c) 2025 [State Bank of India]
 * All rights reserved
 * *
 */
@Repository
@RequiredArgsConstructor
public class ErrorLogDao {
    private final LoggerUtility logger = LoggerFactoryUtility.getLogger(this.getClass());

    private final ErrorLogRepository errorLogRepository;
    private final ErrorMapper errorMapper;

    public void saveErrorLog(ErrorLogDto errorLogDto) {
        logger.info("Saving Error Log : {}", errorLogDto);
        errorLogRepository.save(errorMapper.dtoToEntity(errorLogDto));
        logger.info("Error Log Saved Successfully.");
    }
}
package com.epay.transaction.dto;

import com.epay.transaction.util.enums.EntityType;
import com.epay.transaction.util.enums.FailureReason;
import com.epay.transaction.util.enums.PayMode;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import lombok.Builder;
import lombok.Data;

@Data
@Builder
public class ErrorLogDto {
    private String mId;
    private String orderRefNumber;
    private String sbiOrderRefNumber;
    private String atrn;

    @Enumerated(EnumType.STRING)
    private EntityType entityType;

    @Enumerated(EnumType.STRING)
    private PayMode payMode;

    @Enumerated(EnumType.STRING)
    private FailureReason failureReason;

    private String errorCode;
    private String errorMessage;
}


can we create 3 different method based on reason type in ErrorLogDao only, and pass the Error Code and message and entity type in it. So it will look more clean and common place for all object creation
