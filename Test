
package com.epay.merchant.dao;

import com.epay.merchant.dto.FooterDto;
import com.epay.merchant.dto.MerchantEntityGroupDto;
import com.epay.merchant.dto.MerchantUserDto;
import com.epay.merchant.dto.OnboardingDto;
import com.epay.merchant.entity.Footer;
import com.epay.merchant.entity.MerchantEntityGroup;
import com.epay.merchant.entity.MerchantInfo;
import com.epay.merchant.externalservice.AdminServicesClient;
import com.epay.merchant.externalservice.response.BankDetailsResponse;
import com.epay.merchant.externalservice.response.BankResponse;
import com.epay.merchant.externalservice.response.BranchResponse;
import com.epay.merchant.mapper.MerchantMapper;
import com.epay.merchant.model.request.FooterRequest;
import com.epay.merchant.model.request.OnboardingRequest;
import com.epay.merchant.repository.FooterRepository;
import com.epay.merchant.repository.MerchantEntityGroupRepository;
import com.epay.merchant.repository.MerchantEntityUserRepository;
import com.epay.merchant.repository.MerchantRepository;
import com.epay.merchant.util.enums.MerchantStatus;
import com.epay.merchant.util.enums.UserStatus;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;


@Component
@RequiredArgsConstructor
public class AdminDao {

    private final LoggerUtility log = LoggerFactoryUtility.getLogger(this.getClass());

    private final MerchantRepository merchantRepository;
    private final MerchantUserDao merchantUserDao;
    private final MerchantEntityGroupRepository merchantEntityGroupRepository;
    private final MerchantMapper mapper;
    private final FooterRepository footerRepository;
    private final AdminServicesClient adminServicesClient;
    private final MerchantEntityUserRepository merchantEntityUserRepository;


    @Transactional
    public OnboardingDto onboardingMerchantAndMerchantUser(OnboardingRequest onboardingRequest) {
        log.info("Onboarding request received");
        // Step 1 : Onboard Merchant
        MerchantInfo merchantInfo = mapper.mapMerchantDtoToEntity(onboardingRequest.getMerchant());
        merchantInfo.setStatus(MerchantStatus.ACTIVE.name());
        merchantInfo = merchantRepository.save(merchantInfo);
        // Step 2 : Onboard Merchant User
        MerchantUserDto merchantUserDto = merchantUserDao.saveMerchantUser(onboardingRequest.getUser(), merchantInfo.getMId());
        // Step 3 : Build Onboarding response
        return OnboardingDto.builder().merchant(mapper.mapMerchantInfoEntityToDto(merchantInfo)).user(merchantUserDto).build();
    }

   
    public boolean isMerchantExistByMId(String mId) {
        return merchantRepository.existsBymIdAndStatus(mId, MerchantStatus.ACTIVE.name());
    }


    public boolean isMerchantUserExist(String userName, String email, String mobilePhone) {
        return merchantUserDao.existsByUserNameOrEmailOrMobilePhoneAndStatus(userName, email, mobilePhone, UserStatus.ACTIVE);
    }


    public boolean isMerchantUserExistByUserId(UUID userId) {
        return merchantUserDao.isMerchantUserExistByUserId(userId);
    }


    public boolean isMerchantUserExistWithRoles(String userName, List<String> roles) {
        return merchantUserDao.existsByUserNameOrEmailOrMobilePhoneAndRoles(userName, roles);
    }


    public boolean isMerchantUserExistWithRoles(UUID userId, List<String> roles) {
        return merchantUserDao.existsByUserIdAndRoles(userId, roles);
    }

    public Page<MerchantUserDto> findAllMerchantUsersByMId(String mId, Pageable pageable) {
        return merchantUserDao.getAllMerchantUsersByMId(mId, pageable);
    }


    public List<String> findMappedEntityMIds(List<String> mIds) {
        return merchantEntityGroupRepository.findExistingMIds(mIds);
    }


    public List<String> findInvalidsMIds(List<String> mIds) {
        List<String> inActiveMIds = new ArrayList<>(mIds);
        List<String> activeMIds = merchantRepository.findActiveMIds(mIds);
        inActiveMIds.removeAll(activeMIds);
        return inActiveMIds;
    }


    public boolean isEntityIdPresent(String entityId) {
        return merchantEntityGroupRepository.existsByEntityId(entityId);
    }


    public MerchantEntityGroupDto saveMerchantEntityGroup(MerchantEntityGroupDto merchantEntityGroupDto) {
        List<MerchantEntityGroup> merchantEntityGroups = merchantEntityGroupDto.getMIds().stream().map(mId -> MerchantEntityGroup.builder().entityId(merchantEntityGroupDto.getEntityId()).mId(mId).build()).collect(Collectors.toList());
        merchantEntityGroupRepository.saveAll(merchantEntityGroups);
        return merchantEntityGroupDto;
    }

    public void updateUserRole(String userId, String userName, String entityId) {
        merchantUserDao.updateMerchantUserRole(userId, userName, entityId);
    }

    public BankDetailsResponse getBankDetailsByIfscCode(String ifsc) {
        log.info("Fetching bank details from external service for IFSC Code: {}", ifsc);
        return adminServicesClient.getBankDetailsByIfscCode(ifsc).getFirst();
    }


    public List<BankResponse> getAllBanks() {
        log.info("Fetching all banks from external service");
        return adminServicesClient.getAllBanks();
    }


    public List<BranchResponse> getAllBranches(String bankId) {
        log.info("Fetching all branches for bank ID {} from external service", bankId);
        return adminServicesClient.getAllBranches(bankId);
    }

    @Transactional
    public void saveFooterRequest(FooterRequest footerLabelRequest) {
        for (FooterDto footerLabelDto : footerLabelRequest.getFooterLabels()) {
            Footer footerResponse = footerRepository.findByLabel(footerLabelDto.getLabel().trim()).orElse(Footer.builder().label(footerLabelDto.getLabel().trim()).build());
            footerResponse.setValue(footerLabelDto.getValue());
            footerRepository.save(footerResponse);
        }
    }


    public boolean isUserAlreadyMappedToEntity(UUID userId, String entityId) {
        return !merchantEntityUserRepository.findByUserIdAndEntityId(userId, entityId).isEmpty();
    }

    /**
     * Get userId by userName
     *
     * @param userName String
     * @return UUD
     **/
    public MerchantUserDto getMerchantIdByUserName(String userName) {
        return merchantUserDao.getByUserName(userName, UserStatus.ACTIVE);
    }
}


package com.epay.merchant.externalservice;

import com.epay.merchant.client.ApiClient;
import com.epay.merchant.exception.MerchantException;
import com.epay.merchant.externalservice.request.AdminBankVerification;
import com.epay.merchant.externalservice.response.*;
import com.epay.merchant.model.response.MerchantResponse;
import com.epay.merchant.util.ErrorConstants;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.commons.collections4.CollectionUtils;
import org.springframework.core.ParameterizedTypeReference;
import reactor.core.publisher.Mono;

import java.net.URI;
import java.util.*;
import java.util.stream.Collectors;

public class AdminServicesClient extends ApiClient {

    public static final String DOWNTIME_API_ENDPOINT = "/payMode/downtime";
    public static final String MERCHANT_PAYMODE_API = "/merchant/payMode/";
    public static final String BANK_ACCOUNT_VALIDATION = "/bank/validate";
    public static final String BANK_ENDPOINT = "/bank";
    public static final String BRANCH_DETAILS_ENDPOINT = "/bank/branch/";

    public static final String DATA = "data";
    public static final String PAY_MODES = "payModes";
    public static final String PREFERRED_OPTIONS = "preferredOptions";
    public static final String PAYMENT_OPTIONS = "otherPaymentOptions";
    public static final String INB = "INB";
    public static final String UPI = "UPI";
    public static final String UPI_KEY_BHIMQR = "BHIMQR";
    public static final String UPI_KEY_SELF = "self";

    private final ObjectMapper mapper = new ObjectMapper();

    public AdminServicesClient(String baseUrl, String corsOrigin) {
        super(baseUrl, corsOrigin);
    }

    private static void setUpMerchantDownTimeResponse(HashMap<String, MerchantDownTimeResponse> merchantDownTimeResponses, String payMode, List<MerchantDownTimeDetails> downtimeDetails, MerchantDownTimeResponse downTimeResponse) {

        if (merchantDownTimeResponses.containsKey(payMode)) {
            MerchantDownTimeResponse merchantDownTimeResponse = merchantDownTimeResponses.get(payMode);
            int downTimeCount = setDowntimeCount(downtimeDetails);
            merchantDownTimeResponse.setDowntimeCount(downTimeResponse.getDowntimeCount() + downTimeCount);
            merchantDownTimeResponse.getDownTimeDetails().addAll(downtimeDetails);
        } else {
            downTimeResponse.setDownTimeDetails(downtimeDetails);
            int downTimeCount = setDowntimeCount(downtimeDetails);
            downTimeResponse.setDowntimeCount(downTimeResponse.getDowntimeCount() + downTimeCount);
            merchantDownTimeResponses.put(payMode, downTimeResponse);
        }
    }

    private static int setDowntimeCount(List<MerchantDownTimeDetails> downtimeDetails) {
        return (int) downtimeDetails.stream().filter(MerchantDownTimeDetails::isPayModeDown).count();
    }

    public List<AdminDowntimePayModeInfo> getDowntimeAPIs() {
        return getList(DOWNTIME_API_ENDPOINT, new ParameterizedTypeReference<>() {});
    }

    public List<MerchantDownTimeResponse> getMerchantDowntimeAPIs(String mId) {
        Set<String> paymentGateWayId = getMerchantDowntimeAPIs();
        URI uri = URI.create(getBaseUrl() + MERCHANT_PAYMODE_API + mId);
        JsonNode responseNode = getWebClient().post().uri(uri).headers(httpHeaders -> httpHeaders.addAll(prepareHttpHeaders())).retrieve().onStatus(httpStatusCode -> httpStatusCode.is4xxClientError() || httpStatusCode.is5xxServerError(), clientResponse -> Mono.error(new MerchantException(ErrorConstants.INVALID_ERROR_CODE, ErrorConstants.INVALID_ERROR_CODE))).bodyToMono(JsonNode.class).block();
        HashMap<String, MerchantDownTimeResponse> merchantDownTimeResponses = new HashMap<>();
        if (responseNode != null && responseNode.path(DATA) != null && !responseNode.path(DATA).isEmpty() && responseNode.path(DATA).get(0).path(PAY_MODES) != null) {
            JsonNode payModes = responseNode.path(DATA).get(0).path(PAY_MODES);
            setUpDownTimeForPayModes(payModes, PREFERRED_OPTIONS, merchantDownTimeResponses, paymentGateWayId);
            setUpDownTimeForPayModes(payModes, PAYMENT_OPTIONS, merchantDownTimeResponses, paymentGateWayId);
        }
        return merchantDownTimeResponses.keySet().stream().map(merchantDownTimeResponses::get).collect(Collectors.toList());
    }

    public List<String> validateBankDetails(String bankName, String branchName, String ifscCode) {
        AdminBankVerification adminBankVerification = AdminBankVerification.builder().bankName(bankName).branchName(branchName).ifscCode(ifscCode).build();
        return postList(BANK_ACCOUNT_VALIDATION, adminBankVerification, new ParameterizedTypeReference<>() {});
    }


    public List<BankDetailsResponse> getBankDetailsByIfscCode( String ifscCode) {
        return getList(BANK_ENDPOINT + "/" + ifscCode, new ParameterizedTypeReference<>() {});
    }

  
    public List<BankResponse> getAllBanks() {
        return getList(BANK_ENDPOINT, new ParameterizedTypeReference<>() {});
    }


    public List<BranchResponse> getAllBranches(String bankId) {
        return getList(BRANCH_DETAILS_ENDPOINT + bankId, new ParameterizedTypeReference<>() {});
    }

    private Set<String> getMerchantDowntimeAPIs() {
        URI uri = URI.create(getBaseUrl() + DOWNTIME_API_ENDPOINT);
        List<HashMap<String, String>> block = getWebClient().get().uri(uri).headers(httpHeaders -> httpHeaders.addAll(prepareHttpHeaders())).retrieve().onStatus(httpStatusCode -> httpStatusCode.is4xxClientError() || httpStatusCode.is5xxServerError(), clientResponse -> Mono.error(new MerchantException(ErrorConstants.INVALID_ERROR_CODE, ErrorConstants.INVALID_ERROR_CODE))).bodyToMono(new ParameterizedTypeReference<MerchantResponse<HashMap<String, String>>>() {
        }).map(MerchantResponse::getData).block();

        if (CollectionUtils.isNotEmpty(block)) {
            return block.stream().filter(map -> map.containsKey("gatewayId")).map(map -> map.get("gatewayId")).collect(Collectors.toSet());
        }
        return new HashSet<>();
    }

    private void setUpDownTimeForPayModes(JsonNode payModes, String option, HashMap<String, MerchantDownTimeResponse> merchantDownTimeResponses, Set<String> paymentGateWayId) {
        if (payModes.path(option) != null) {
            JsonNode preferredOptions = payModes.path(option);
            setUpDowntimeInfo(preferredOptions, merchantDownTimeResponses, paymentGateWayId);
        }
    }

    private void setUpDowntimeInfo(JsonNode preferredOptions, HashMap<String, MerchantDownTimeResponse> merchantDownTimeResponses, Set<String> paymentGateWayId) {
        setUPIPayMode(preferredOptions, merchantDownTimeResponses, paymentGateWayId);
        setUpINBPayMode(preferredOptions, merchantDownTimeResponses, paymentGateWayId);
        setCardsPayMode(preferredOptions, merchantDownTimeResponses, paymentGateWayId);
    }

    private void setUPIPayMode(JsonNode preferredOptions, HashMap<String, MerchantDownTimeResponse> merchantDownTimeResponses, Set<String> paymentGateWayId) {
        HashMap<String, Object> upiResponses = mapper.convertValue(preferredOptions.path("upi"), mapper.getTypeFactory().constructMapType(HashMap.class, String.class, Object.class));
        if (!upiResponses.isEmpty() && upiResponses.containsKey(UPI_KEY_SELF) && upiResponses.get(UPI_KEY_SELF) != null) {
            HashMap<String, Object> selfResponse = (HashMap<String, Object>) upiResponses.get(UPI_KEY_SELF);
            if (!selfResponse.isEmpty() && selfResponse.keySet().containsAll(List.of("bankName", "aggregatorGatewayMapId"))) {
                List<MerchantDownTimeDetails> downtimeDetails = new ArrayList<>();
                downtimeDetails.add(MerchantDownTimeDetails.builder().code("UPI").name((String) selfResponse.get("bankName")).paymentGateWayId((String) selfResponse.get("aggregatorGatewayMapId")).isPayModeDown(paymentGateWayId.contains((String) selfResponse.get("aggregatorGatewayMapId"))).build());
                setUpMerchantDownTimeResponse(merchantDownTimeResponses, UPI, downtimeDetails, MerchantDownTimeResponse.builder().payMode(UPI).build());
            }
        }
        if (!upiResponses.isEmpty() && upiResponses.containsKey(UPI_KEY_BHIMQR) && upiResponses.get(UPI_KEY_BHIMQR) != null) {
            HashMap<String, Object> qrResponse = (HashMap<String, Object>) upiResponses.get(UPI_KEY_BHIMQR);
            if (!qrResponse.isEmpty() && qrResponse.keySet().containsAll(List.of("bankName", "aggregatorGatewayMapId"))) {
                List<MerchantDownTimeDetails> downtimeDetails = new ArrayList<>();
                downtimeDetails.add(MerchantDownTimeDetails.builder().code("QR").name((String) qrResponse.get("bankName")).paymentGateWayId((String) qrResponse.get("aggregatorGatewayMapId")).isPayModeDown(paymentGateWayId.contains((String) qrResponse.get("aggregatorGatewayMapId"))).build());
                setUpMerchantDownTimeResponse(merchantDownTimeResponses, UPI, downtimeDetails, MerchantDownTimeResponse.builder().payMode(UPI).build());
            }
        }
    }

    private void setUpINBPayMode(JsonNode preferredOptions, HashMap<String, MerchantDownTimeResponse> merchantDownTimeResponses, Set<String> paymentGateWayId) {
        List<HashMap<String, Object>> bankResponses = mapper.convertValue(preferredOptions.path("inb"), mapper.getTypeFactory().constructCollectionType(List.class, HashMap.class));
        if (CollectionUtils.isNotEmpty(bankResponses)) {
            List<MerchantDownTimeDetails> downtimeDetails = new ArrayList<>();
            for (HashMap<String, Object> map : bankResponses) {
                if (!map.isEmpty() && map.keySet().containsAll(List.of("bankId", "bankName", "aggregatorGatewayMapId"))) {
                    downtimeDetails.add(MerchantDownTimeDetails.builder().code((String) map.get("bankId")).name((String) map.get("bankName")).paymentGateWayId((String) map.get("aggregatorGatewayMapId")).isPayModeDown(paymentGateWayId.contains((String) map.get("aggregatorGatewayMapId"))).build());
                }
            }
            setUpMerchantDownTimeResponse(merchantDownTimeResponses, INB, downtimeDetails, MerchantDownTimeResponse.builder().payMode(INB).build());
        }
    }

    private void setCardsPayMode(JsonNode preferredOptions, HashMap<String, MerchantDownTimeResponse> merchantDownTimeResponses, Set<String> paymentGateWayId) {
        HashMap<String, Object> cardResponses = mapper.convertValue(preferredOptions.path("cards"), mapper.getTypeFactory().constructMapType(HashMap.class, String.class, Object.class));
        setCardPayMode(cardResponses, "cc", merchantDownTimeResponses, paymentGateWayId);
        setCardPayMode(cardResponses, "dc", merchantDownTimeResponses, paymentGateWayId);
        setCardPayMode(cardResponses, "pc", merchantDownTimeResponses, paymentGateWayId);
    }

    private void setCardPayMode(HashMap<String, Object> cardResponses, String cardType, HashMap<String, MerchantDownTimeResponse> merchantDownTimeResponses, Set<String> paymentGateWayId) {
        if (cardResponses.get(cardType) != null) {
            List<MerchantDownTimeDetails> downtimeDetails = new ArrayList<>();
            List<HashMap<String, Object>> dcCardDetails = mapper.convertValue(cardResponses.get(cardType), mapper.getTypeFactory().constructCollectionType(List.class, HashMap.class));
            for (HashMap<String, Object> cardInfo : dcCardDetails) {
                if (!cardInfo.isEmpty() && cardInfo.keySet().containsAll(List.of("payproc", "bankName", "aggregatorGatewayMapId"))) {
                    downtimeDetails.add(MerchantDownTimeDetails.builder().code((String) cardInfo.get("payproc")).name((String) cardInfo.get("bankName")).paymentGateWayId((String) cardInfo.get("aggregatorGatewayMapId")).isPayModeDown(paymentGateWayId.contains((String) cardInfo.get("aggregatorGatewayMapId"))).build());
                }
            }
            setUpMerchantDownTimeResponse(merchantDownTimeResponses, cardType, downtimeDetails, MerchantDownTimeResponse.builder().payMode("cards").subPayMode(cardType).build());
        }
    }
}

