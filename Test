
    public boolean isValidCurrencyCode(String mId, String currencyCode) {
        CurrencyRequest currencyRequest = CurrencyRequest.builder().mId(mId).currencyCode(currencyCode).build();
        TransactionResponse<?> response = adminServicesClient.getCurrencyValidate(currencyRequest);
        return TransactionConstant.RESPONSE_SUCCESS == response.getStatus();
    }

    public MerchantRfcDetailsResponse getMerchantRFCDetails(String mId) {
        TransactionResponse<MerchantRfcDetailsResponse> response = adminServicesClient.getMerchantRFCInfo(mId);
        if (TransactionConstant.RESPONSE_SUCCESS == response.getStatus() && CollectionUtils.isNotEmpty(response.getData())) {
            return response.getData().getFirst();
        }
        logger.error("Error in getMerchantRFCDetails {}", response.getErrors());
        throw new TransactionException(TransactionErrorConstants.NOT_FOUND_ERROR_CODE, MessageFormat.format(TransactionErrorConstants.NOT_FOUND_ERROR_MESSAGE, "MerchantRFCDetails"));
    }

    public Map<String, List<String>> getMerchantMultiAccount(String mId) {
        TransactionResponse<Map<String, List<String>>> response = adminServicesClient.getMultiAccountDetailsApi(mId);
        if (TransactionConstant.RESPONSE_SUCCESS == response.getStatus() && CollectionUtils.isNotEmpty(response.getData())) {
            return response.getData().getFirst();
        }
        logger.error("Error in getMerchantMultiAccount {}", response.getErrors());
        throw new TransactionException(TransactionErrorConstants.NOT_FOUND_ERROR_CODE, MessageFormat.format(TransactionErrorConstants.NOT_FOUND_ERROR_MESSAGE, "MerchantRFCDetails"));
    }

    public JsonNode getMerchantPayModes(String mId) {
        TransactionResponse<JsonNode> response = adminServicesClient.getMerchantPayModeInfo(mId);
        if (TransactionConstant.RESPONSE_SUCCESS == response.getStatus() && CollectionUtils.isNotEmpty(response.getData())) {
            return response.getData().getFirst().get("paymodes");
        }
        logger.error("Error in getMerchantPayModes {}", response.getErrors());
        throw new TransactionException(TransactionErrorConstants.NOT_FOUND_ERROR_CODE, MessageFormat.format(TransactionErrorConstants.NOT_FOUND_ERROR_MESSAGE, "MerchantRFCDetails"));
    }

    public List<MerchantVolumeVelocityResponse> getMerchantVVLDetails(String mId) {
        TransactionResponse<MerchantVolumeVelocityResponse> response = adminServicesClient.geVvlDetails(mId);
        if (TransactionConstant.RESPONSE_SUCCESS == response.getStatus() && CollectionUtils.isNotEmpty(response.getData())) {
            return response.getData();
        }
        logger.error("Error in getMerchantVVLDetails {}", response.getErrors());
        throw new TransactionException(TransactionErrorConstants.NOT_FOUND_ERROR_CODE, MessageFormat.format(TransactionErrorConstants.NOT_FOUND_ERROR_MESSAGE, "MerchantVVLDetails"));
    }

    public GatewayConfigDetailsResponse getGatewayConfigDetails(String mId, String gateWayMapId) {
        TransactionResponse<GatewayConfigDetailsResponse> response = adminServicesClient.getGatewayConfigDetails(mId, gateWayMapId);
        if (TransactionConstant.RESPONSE_SUCCESS == response.getStatus() && CollectionUtils.isNotEmpty(response.getData())) {
            return response.getData().getFirst();
        }
        logger.error("Error in getGatewayConfigDetails {}", response.getErrors());
        throw new TransactionException(TransactionErrorConstants.NOT_FOUND_ERROR_CODE, MessageFormat.format(TransactionErrorConstants.NOT_FOUND_ERROR_MESSAGE, "GatewayConfigDetails"));
    }

    public MerchantPricingResponse getValidMerchantPricingStructure(MerchantPricingRequest merchantPricingRequest) {
        TransactionResponse<MerchantPricingResponse> response = adminServicesClient.getMerchantPricingStructure(merchantPricingRequest);
        if (TransactionConstant.RESPONSE_SUCCESS == response.getStatus() && CollectionUtils.isNotEmpty(response.getData())) {
            MerchantPricingResponse merchantPricingResponse = response.getData().getFirst();
            if (ObjectUtils.isEmpty(merchantPricingResponse.getFeeProcessingFlag()) || !merchantPricingResponse.getFeeProcessingFlag().equals(TransactionConstant.TRANSACTION_PROCESSING_FLAG_HYBRID)) {
                logger.info("Processing flag validation failed for MerchantPricingResponse: {}", merchantPricingResponse);
                throw new ValidationException(TransactionErrorConstants.NOT_FOUND_ERROR_CODE, MessageFormat.format(TransactionErrorConstants.NOT_FOUND_ERROR_MESSAGE, "Hybrid transaction processing flag"));
            }
            if (ObjectUtils.isEmpty(merchantPricingResponse.getBearableComponent()) || !(merchantPricingResponse.getBearableComponent().equalsIgnoreCase(TransactionConstant.BEARABLE_COMPONENT_FEE) || merchantPricingResponse.getBearableComponent().equalsIgnoreCase(TransactionConstant.BEARABLE_COMPONENT_AMOUNT))) {
                logger.info("Bearable component validation failed for MerchantPricingResponse: {}", merchantPricingResponse);
                throw new ValidationException(TransactionErrorConstants.NOT_FOUND_ERROR_CODE, MessageFormat.format(TransactionErrorConstants.NOT_FOUND_ERROR_MESSAGE, "Valid bearable compound"));
            }
            return merchantPricingResponse;
        }
        logger.error("Error in getMerchantPricingStructure {}", response.getErrors());
        throw new TransactionException(TransactionErrorConstants.NOT_FOUND_ERROR_CODE, MessageFormat.format(TransactionErrorConstants.NOT_FOUND_ERROR_MESSAGE, "Merchant Pricing information"));
    }

    public BinCheckResponse getBinCheckResponse(BinCheckRequest binCheckRequest) {
        TransactionResponse<BinCheckResponse> response = adminServicesClient.binCheckRequest(binCheckRequest);
        
        if (TransactionConstant.RESPONSE_SUCCESS == response.getStatus() && CollectionUtils.isNotEmpty(response.getData())) {
            return response.getData().getFirst();
        }
        logger.error("Error in getBinCheckResponse {}", response.getErrors());
        throw new TransactionException(TransactionErrorConstants.NOT_FOUND_ERROR_CODE, MessageFormat.format(TransactionErrorConstants.NOT_FOUND_ERROR_MESSAGE, "CardBinCheck"));
    }
add method defination and logger like this

/**
     * Getting Merchant Information Using mId
     *
     * @param mId String
     * @return MerchantInfoResponse
     */
    public MerchantInfoResponse getMerchantByMId(String mId) {
        TransactionResponse<MerchantInfoResponse> response = adminServicesClient.getMerchantInfoByMId(mId);
        if (TransactionConstant.RESPONSE_SUCCESS == response.getStatus() && CollectionUtils.isNotEmpty(response.getData())) {
            return response.getData().getFirst();
        }
        logger.error("Error in getMerchantByMId {}", response.getErrors());
        throw new TransactionException(TransactionErrorConstants.NOT_FOUND_ERROR_CODE, MessageFormat.format(TransactionErrorConstants.NOT_FOUND_ERROR_MESSAGE, "MId"));
    }
