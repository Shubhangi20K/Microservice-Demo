
package com.epay.transaction.dao;

import com.epay.transaction.dto.MerchantPaymentOrderDto;
import com.epay.transaction.entity.MerchantOrderPayment;
import com.epay.transaction.exceptions.TransactionException;
import com.epay.transaction.mapper.MerchantOrderPaymentMapper;
import com.epay.transaction.model.request.MarkTransactionFailRequest;
import com.epay.transaction.model.request.MerchantOrderPaymentSearchRequest;
import com.epay.transaction.model.response.MerchantOrderResponse;
import com.epay.transaction.repository.MerchantOrderPaymentRepository;
import com.epay.transaction.specification.TransactionSpecification;
import com.epay.transaction.util.EPayIdentityUtil;
import com.epay.transaction.util.TransactionErrorConstants;
import com.epay.transaction.util.enums.PaymentStatus;
import com.epay.transaction.util.enums.TransactionStatus;
import com.sbi.epay.authentication.providers.EPayTokenProvider;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import lombok.RequiredArgsConstructor;
import org.apache.commons.lang3.StringUtils;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Component;

import java.text.MessageFormat;
import java.util.List;

/**
 * DAO class for handling merchant order payment-related database operations.
 */
@Component
@RequiredArgsConstructor
public class MerchantOrderPaymentDao {

    private final LoggerUtility logger = LoggerFactoryUtility.getLogger(this.getClass());

    private final MerchantOrderPaymentRepository merchantOrderPaymentRepository;
    private final MerchantOrderPaymentMapper merchantOrderPaymentMapper;
    private final EPayTokenProvider ePayTokenProvider;
    private final TokenDao tokenDao;

    /**
     * Retrieves the encrypted AES key using the current authentication token.
     *
     * @return Encrypted AES key as a String.
     */
    public String getEncryptedAESKey() {
        logger.info("Fetching encrypted AES key.");
        return tokenDao.getEncryptionAESKey(ePayTokenProvider.getToken());
    }

    /**
     * Saves a merchant payment order in the database.
     *
     * @param merchantPaymentOrderDto DTO containing merchant order payment details.
     * @return Saved merchant payment order as a DTO.
     */
    public MerchantPaymentOrderDto save(MerchantPaymentOrderDto merchantPaymentOrderDto) {
        logger.info("Saving MerchantOrderPayment entity.");
        MerchantOrderPayment merchantOrderPayment = merchantOrderPaymentMapper.dtoToEntity(merchantPaymentOrderDto);
        MerchantOrderPayment savedEntity = merchantOrderPaymentRepository.save(merchantOrderPayment);
        logger.debug("MerchantOrderPayment saved: {}", savedEntity);
        return merchantOrderPaymentMapper.entityToDto(savedEntity);
    }

    /**
     * Marks a merchant order payment status as FAILED.
     *
     * @param markTransactionFailRequest Request containing transaction failure details.
     */
    public void markMerchantOrderPaymentStatusFail(MarkTransactionFailRequest markTransactionFailRequest) {
        logger.debug("Starting update for merchantOrderPayment status.");
        String mId = EPayIdentityUtil.getUserPrincipal().getMId();
        
        MerchantOrderPayment merchantOrderPayment = merchantOrderPaymentRepository
                .findBymIdAndAtrnNumber(mId, markTransactionFailRequest.getAtrn())
                .orElseThrow(() -> new TransactionException(TransactionErrorConstants.NOT_FOUND_ERROR_CODE,
                        MessageFormat.format(TransactionErrorConstants.NOT_FOUND_ERROR_MESSAGE, "MerchantOrder Payment")));

        if (StringUtils.isEmpty(merchantOrderPayment.getAtrnNumber()) ||
            PaymentStatus.SUCCESS.equals(merchantOrderPayment.getPaymentStatus()) ||
            PaymentStatus.FAILED.equals(merchantOrderPayment.getPaymentStatus())) {
            logger.warn("Transaction already updated or invalid.");
            throw new TransactionException(TransactionErrorConstants.INVALID_ERROR_CODE,
                    MessageFormat.format(TransactionErrorConstants.INVALID_ERROR_MESSAGE, "Atrn", "Atrn status is already updated"));
        }

        merchantOrderPayment.setTransactionStatus(TransactionStatus.FAILED);
        merchantOrderPayment.setPaymentStatus(PaymentStatus.FAILED);
        merchantOrderPayment.setFailReason(markTransactionFailRequest.getFailReason());

        merchantOrderPayment = merchantOrderPaymentRepository.save(merchantOrderPayment);
        logger.info("Updated merchantOrderPayment status: {}", merchantOrderPayment);
        merchantOrderPaymentMapper.entityToDto(merchantOrderPayment);
    }

    /**
     * Validates if a merchant order payment exists for a given SBI order reference number and transaction statuses.
     *
     * @param sbiOrderRefNumber SBI order reference number.
     * @param statusList        List of valid transaction statuses.
     * @return True if at least one matching record exists, false otherwise.
     */
    public boolean validatedMerchantOrderPaymentForBooking(String sbiOrderRefNumber, List<String> statusList) {
        logger.debug("Validating MerchantOrderPayment for booking with SBI order reference: {}", sbiOrderRefNumber);
        return merchantOrderPaymentRepository.countBySbiOrderRefNumberAndTransactionStatusIn(sbiOrderRefNumber, statusList) > 0;
    }

    /**
     * Fetches a summary of card payment details for a given altHash.
     *
     * @param altHash Unique identifier for card payment.
     * @return Array of objects containing payment summary details.
     */
    public Object[] cardPaymentSummary(String altHash) {
        logger.info("Fetching card payment summary for altHash: {}", altHash);
        return merchantOrderPaymentRepository.cardPaymentSummary(altHash);
    }

    /**
     * Finds a MerchantOrderPayment record using an ATRN number.
     *
     * @param atrn ATRN number of the transaction.
     * @return MerchantOrderPayment details as a DTO.
     */
    public MerchantPaymentOrderDto findByAtrnNumber(String atrn) {
        logger.debug("Fetching MerchantOrderPayment for ATRN: {}", atrn);
        MerchantOrderPayment merchantOrderPayment = merchantOrderPaymentRepository
                .findByAtrnNumber(atrn)
                .orElseThrow(() -> new TransactionException(TransactionErrorConstants.NOT_FOUND_ERROR_CODE,
                        MessageFormat.format(TransactionErrorConstants.NOT_FOUND_ERROR_MESSAGE, "MerchantOrderPayment detail")));

        return merchantOrderPaymentMapper.entityToDto(merchantOrderPayment);
    }

    /**
     * Searches merchant order payments using dynamic specifications.
     *
     * @param mId                           Merchant ID.
     * @param merchantOrderPaymentSearchRequest Search criteria.
     * @param pageable                      Pagination details.
     * @return Paginated list of matching MerchantOrderResponse objects.
     */
    public Page<MerchantOrderResponse> findBySpecification(String mId, 
                                                           MerchantOrderPaymentSearchRequest merchantOrderPaymentSearchRequest, 
                                                           Pageable pageable) {
        logger.info("Searching MerchantOrderPayments for mId: {}", mId);
        Specification<MerchantOrderPayment> specification = TransactionSpecification.searchTransaction(mId, merchantOrderPaymentSearchRequest);
        return merchantOrderPaymentRepository.findAll(specification, pageable).map(this::convertEntityToMerchantOrderResponse);
    }

    /**
     * Converts a MerchantOrderPayment entity to a MerchantOrderResponse DTO.
     *
     * @param merchantOrderPayment MerchantOrderPayment entity.
     * @return Converted MerchantOrderResponse DTO.
     */
    private MerchantOrderResponse convertEntityToMerchantOrderResponse(MerchantOrderPayment merchantOrderPayment) {
        return merchantOrderPaymentMapper.entityToMerchantOrderResponse(merchantOrderPayment);
    }
}
