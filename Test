package com.sbi.epay.encryptdecrypt.service;


import com.sbi.epay.encryptdecrypt.constant.EncryptionDecryptionConstants;
import com.sbi.epay.encryptdecrypt.exception.EncryptionDecryptionException;
import com.sbi.epay.encryptdecrypt.util.enums.EncryptionDecryptionAlgo;
import com.sbi.epay.encryptdecrypt.util.enums.GCMIvLength;
import com.sbi.epay.encryptdecrypt.util.enums.GCMTagLength;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import lombok.NonNull;

import javax.crypto.*;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Base64;

/**
 * Class Name: EncryptionService
 * *
 * Description:This class will be used for  encryption using AES-GSM-NOPADDING algorithm
 * *
 * Author: V1018212(Hrishikesh Pandirakar)
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * *
 * Version:1.0
 */

public class EncryptionService {
    private static final LoggerUtility log = LoggerFactoryUtility.getLogger(EncryptionService.class);

    /**
     * Encrypts the given SecretKey using the another SecretKey.
     *
     * @param key   the SecretKey by which we want use for encrypting the given key
     * @param value value which we want to encrypt
     * @return the String of encrypted and encoded KEK
     */
    public static String encryptValueByStringKey(@NonNull String key, @NonNull String value, @NonNull EncryptionDecryptionAlgo algorithm, @NonNull GCMIvLength gcmIvLength, @NonNull GCMTagLength gcmTagLength) throws EncryptionDecryptionException {
        log.debug("EncryptionService encryptValueByStringKey key : {} keyToEncrypt: {} ", key, value);
        return encryptValueBySecretKey(decodedValue(key), value, algorithm, gcmIvLength, gcmTagLength);
    }

    /**
     * Encrypts the given plain-text using the SecretKey.
     *
     * @param key          the SecretKey by which we want use for encrypting the given text
     * @param value        String which we want to encrypt
     * @param algorithm    EncryptionDecryptionAlgo algorithm
     * @param gcmIvLength  algorithm iv length
     * @param gcmTagLength algorithm tag length
     * @return the String of encrypted plain-text
     */
    public static String encryptValueBySecretKey(@NonNull SecretKey key, @NonNull String value, @NonNull EncryptionDecryptionAlgo algorithm, @NonNull GCMIvLength gcmIvLength, @NonNull GCMTagLength gcmTagLength) throws EncryptionDecryptionException {
        try {
            log.info("EncryptionService :: encryptValueBySecretKey  key : {}, value : {}, algorithm : {}, gcmIvLength : {}, gcmTagLength : {}", key, value, algorithm, gcmIvLength, gcmTagLength);
            return encrypt(key, value, algorithm, gcmIvLength, gcmTagLength);
        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException |
                 InvalidAlgorithmParameterException | IllegalArgumentException | UnsupportedOperationException |
                 IllegalStateException | IllegalBlockSizeException | BadPaddingException e) {
            log.error("EncryptionService :: encrypt  {}", e);
            throw new EncryptionDecryptionException(EncryptionDecryptionConstants.GENERIC_ERROR_CODE, EncryptionDecryptionConstants.GENERIC_ERROR_MESSAGE);
        }
    }

    /**
     * This method will be used for decode a SecretKey key
     *
     * @param key it specifies the String of encoded SecretKey
     * @return the SecretKey
     */
    public static SecretKey decodedValue(@NonNull String key) {
        log.info("EncryptionService :: decodedSecretKey ");
        byte[] decodedKey = Base64.getDecoder().decode(key);
        return new SecretKeySpec(decodedKey, 0, decodedKey.length, "AES");
    }

    public static String encrypt(SecretKey key, String value, EncryptionDecryptionAlgo algorithm, GCMIvLength gcmIvLength, GCMTagLength gcmTagLength) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {
        log.debug("EncryptionService ::  value {}, algorithm {}, gcmIvLength {}, gcmTagLength {}", value, algorithm, gcmIvLength, gcmTagLength);

        // Initialize the Cipher
        Cipher cipher = Cipher.getInstance(algorithm.getName());

        // Generate a random IV using SecureRandom
        byte[] iv = new byte[gcmIvLength.getLengthInBytes()];
        SecureRandom secureRandom = new SecureRandom();
        secureRandom.nextBytes(iv);

        // Initialize the GCMParameterSpec with the IV
        GCMParameterSpec gcmSpec = new GCMParameterSpec(gcmTagLength.getLengthInBits(), iv);

        // Initialize the Cipher in Encrypt Mode with the Key and GCM Parameters
        cipher.init(Cipher.ENCRYPT_MODE, key, gcmSpec);

        // Encrypt the input value
        byte[] ciphertext = cipher.doFinal(value.getBytes(StandardCharsets.UTF_8));

        // Concatenate IV with Ciphertext for storage/transport
        byte[] combined = new byte[iv.length + ciphertext.length];
        System.arraycopy(iv, 0, combined, 0, iv.length);
        System.arraycopy(ciphertext, 0, combined, iv.length, ciphertext.length);

        // Return Base64-encoded string of IV + Ciphertext
        return Base64.getEncoder().encodeToString(combined);
    }

}

