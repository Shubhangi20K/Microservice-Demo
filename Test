
package com.epay.transaction.dao;

import com.epay.transaction.dto.MerchantPaymentOrderDto;
import com.epay.transaction.exceptions.TransactionException;
import com.epay.transaction.externalservice.PaymentServicesClient;
import com.epay.transaction.externalservice.request.payment.*;
import com.epay.transaction.externalservice.response.payment.*;
import com.epay.transaction.model.request.PaymentInitiationRequest;
import com.epay.transaction.model.response.EncryptedResponse;
import com.epay.transaction.model.response.TransactionResponse;
import com.epay.transaction.util.TransactionConstant;
import com.epay.transaction.util.TransactionErrorConstants;
import com.epay.transaction.util.enums.PayMode;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import lombok.RequiredArgsConstructor;
import org.apache.commons.collections4.CollectionUtils;
import org.springframework.stereotype.Service;

import java.text.MessageFormat;

import static com.epay.transaction.util.EncryptionDecryptionUtil.encryptValue;
import static com.epay.transaction.util.TransactionUtil.toJson;
import static com.epay.transaction.util.enums.PayMode.getPayMode;

/**
 * Class Name: PaymentDao
 * <p>
 * Description: This class handles different payment initiation processes,
 * including card payments, net banking, and UPI transactions. It interacts
 * with external payment service clients to process transactions.
 * <p>
 * Author: V1014352 (Ranjan Kumar)
 * <p>
 * Copyright (c) 2025 [State Bank of India]
 * All rights reserved.
 * <p>
 * Version: 1.0
 */
@Service
@RequiredArgsConstructor
public class PaymentDao {
    
    private final LoggerUtility logger = LoggerFactoryUtility.getLogger(this.getClass());
    private final PaymentServicesClient paymentServicesClient;

    /**
     * Initiates a payment based on the provided payment mode.
     *
     * @param payModeString              The payment mode (e.g., CC, DC, UPI, NB).
     * @param merchantPaymentOrderDto    Merchant payment details.
     * @param paymentInitiationRequest   Payment initiation request details.
     * @param key                        Encryption key.
     * @return Encrypted response containing transaction details.
     */
    public EncryptedResponse paymentInitiation(String payModeString, MerchantPaymentOrderDto merchantPaymentOrderDto, PaymentInitiationRequest paymentInitiationRequest, String key) {
        logger.info("Starting payment initiation for payMode: {}", payModeString);
        PayMode payMode = getPayMode(payModeString);
        return switch (payMode) {
            case CC, DC, PC -> processCardPayment(merchantPaymentOrderDto, paymentInitiationRequest, key);
            case NB -> TransactionConstant.SBI_NAME.equalsIgnoreCase(paymentInitiationRequest.getChannelBank())
                    ? initiateNetBankingPayment(merchantPaymentOrderDto, key)
                    : initiateOtherINBPayment(merchantPaymentOrderDto, key);
            case UPI -> handleUpiPayment(merchantPaymentOrderDto, paymentInitiationRequest, key);
            default -> {
                logger.error("Invalid payment mode: {}", payMode);
                throw new TransactionException(TransactionErrorConstants.INVALID_ERROR_CODE, MessageFormat.format(TransactionErrorConstants.INVALID_ERROR_MESSAGE, payMode, "PayMode is not configured for payment"));
            }
        };
    }

    /**
     * Validates a UPI payment VPA.
     *
     * @param paymentUPIVpaRequest The UPI VPA validation request.
     * @param key                  Encryption key.
     * @return Encrypted response with validation result.
     */
    public EncryptedResponse validateUPIPaymentVpa(PaymentUPIVpaRequest paymentUPIVpaRequest, String key) {
        logger.info("Validating UPI VPA: {}", paymentUPIVpaRequest);
        TransactionResponse<PaymentUPIVpaResponse> response = paymentServicesClient.validateUPIPaymentVpa(paymentUPIVpaRequest);
        return handleResponse(response, key, TransactionConstant.PAYMENT_TYPE_VPA);
    }

    /**
     * Checks the status of a UPI payment.
     *
     * @param paymentStatusRequest Payment status request.
     * @param key                  Encryption key.
     * @return Encrypted response with payment status.
     */
    public EncryptedResponse upiPaymentStatusEnquiry(PaymentStatusRequest paymentStatusRequest, String key) {
        logger.info("Checking UPI payment status for request: {}", paymentStatusRequest);
        TransactionResponse<PaymentUPIStatusResponse> response = paymentServicesClient.upiPaymentStatusEnquiry(paymentStatusRequest);
        return handleResponse(response, key, TransactionConstant.PAYMENT_TYPE_VPA);
    }

    /**
     * Processes a card payment transaction.
     */
    private EncryptedResponse processCardPayment(MerchantPaymentOrderDto merchantPaymentOrderDto, PaymentInitiationRequest paymentInitiationRequest, String key) {
        logger.info("Processing card payment for merchant: {}", merchantPaymentOrderDto.getMId());
        PaymentCardRequest paymentCardRequest = buildPaymentCardRequest(merchantPaymentOrderDto, paymentInitiationRequest);
        if (paymentInitiationRequest.getPayProcId().equalsIgnoreCase(TransactionConstant.PAYMENT_TYPE_VISA)
                || paymentInitiationRequest.getPayProcId().equalsIgnoreCase(TransactionConstant.PAYMENT_TYPE_MASTER)) {
            TransactionResponse<PaymentVisaCardResponse> response = paymentServicesClient.initiateVisaAndMasterCardAPI(paymentCardRequest);
            return handleResponse(response, key, paymentInitiationRequest.getPayProcId());
        }
        TransactionResponse<PaymentRupayCardResponse> response = paymentServicesClient.initiateRupPayCardAPI(paymentCardRequest);
        return handleResponse(response, key, paymentInitiationRequest.getPayProcId());
    }

    /**
     * Initiates a net banking payment for SBI.
     */
    private EncryptedResponse initiateNetBankingPayment(MerchantPaymentOrderDto merchantPaymentOrderDto, String key) {
        logger.info("Initiating SBI net banking payment for ATRN: {}", merchantPaymentOrderDto.getAtrnNumber());
        TransactionResponse<PaymentResponse> response = paymentServicesClient.initiateSBIINBPayments(PaymentINBRequest.builder().atrn(merchantPaymentOrderDto.getAtrnNumber()).build());
        return handleResponse(response, key, PayMode.NB.name());
    }

    /**
     * Initiates a net banking payment for other banks.
     */
    private EncryptedResponse initiateOtherINBPayment(MerchantPaymentOrderDto merchantPaymentOrderDto, String key) {
        logger.info("Initiating other INB payment for ATRN: {}", merchantPaymentOrderDto.getAtrnNumber());
        TransactionResponse<PaymentOtherInbResponse> response = paymentServicesClient.initiateOtherINBPayments(buildPaymentOtherInbRequest(merchantPaymentOrderDto));
        return handleResponse(response, key, PayMode.NB.name());
    }

    /**
     * Handles UPI payments based on the payment processor ID.
     */
    private EncryptedResponse handleUpiPayment(MerchantPaymentOrderDto merchantPaymentOrderDto, PaymentInitiationRequest paymentInitiationRequest, String key) {
        logger.info("Processing UPI payment for merchant: {}", merchantPaymentOrderDto.getMId());
        if (paymentInitiationRequest.getPayProcId().equalsIgnoreCase(TransactionConstant.PAY_PROC_ID_SELF)) {
            TransactionResponse<PaymentUPIVpaCollectGatewayResponse> response = paymentServicesClient.initiateUPIVPAPayments(buildPaymentUPIRequest(merchantPaymentOrderDto, paymentInitiationRequest));
            return handleResponse(response, key, PayMode.UPI.name());
        } else if (paymentInitiationRequest.getPayProcId().equalsIgnoreCase(TransactionConstant.PAY_PROC_ID_BHIMQR)) {
            TransactionResponse<PaymentQRResponse> response = paymentServicesClient.initiateUPIQRPayments(buildPaymentUPIQRRequest(merchantPaymentOrderDto, paymentInitiationRequest));
            return handleResponse(response, key, PayMode.UPI.name());
        }
        logger.error("Invalid UPI payment processor ID: {}", paymentInitiationRequest.getPayProcId());
        throw new TransactionException(TransactionErrorConstants.INVALID_ERROR_CODE, TransactionErrorConstants.INVALID_ERROR_MESSAGE);
    }

    /**
     * Handles the response from the payment service and encrypts the result.
     */
    private <T> EncryptedResponse handleResponse(TransactionResponse<T> response, String key, String paymentType) {
        logger.info("Handling response for payment type: {}", paymentType);
        if (TransactionConstant.RESPONSE_SUCCESS == response.getStatus() && CollectionUtils.isNotEmpty(response.getData())) {
            String encryptionResponse = encryptValue(key, toJson(response.getData().getFirst()));
            return EncryptedResponse.builder().encryptedResponse(encryptionResponse).build();
        } else if (TransactionConstant.RESPONSE_FAILURE == response.getStatus() && CollectionUtils.isNotEmpty(response.getErrors())) {
            logger.error("Payment failed with errors: {}", response.getErrors());
            throw new TransactionException(response.getErrors());
        }
        logger.error("Payment processing error for type: {}", paymentType);
        throw new TransactionException(TransactionErrorConstants.PAYMENT_ERROR_CODE, MessageFormat.format(TransactionErrorConstants.PAYMENT_ERROR_MESSAGE, paymentType));
    }
}
