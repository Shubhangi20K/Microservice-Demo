package com.epay.merchant.dao;

import com.epay.merchant.dto.MerchantUserDto;
import com.epay.merchant.entity.MerchantUserRole;
import com.epay.merchant.entity.TokenManagement;
import com.epay.merchant.repository.MerchantUserRoleRepository;
import com.epay.merchant.repository.TokenManagementRepository;
import com.epay.merchant.util.enums.TokenStatus;
import com.epay.merchant.util.enums.UserStatus;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Optional;
import java.util.UUID;
import java.util.stream.StreamSupport;

import static com.epay.merchant.util.MerchantConstant.USER;

/**
 * Class Name: TokenDao
 * Description:
 * TokenDao is responsible for managing database operations related to token management.
 * It interacts with the `TokenManagementRepository` to handle CRUD operations on tokens used for authentication,
 * session management, or other security-related tasks. The class also collaborates with `MerchantUserDao` to manage
 * user-related data associated with tokens, and with `MerchantUserRoleRepository` to handle role-based token assignments
 * or permissions. This DAO helps facilitate secure token operations, ensuring tokens are created, validated, and managed properly.
 * Author: Shikha Sharma
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * Version: 1.0
 */

@Component
@RequiredArgsConstructor
public class TokenDao {

    private final MerchantUserDao merchantUserDao;
    private final MerchantUserRoleRepository userRolesRepository;
    private final TokenManagementRepository tokenManagementRepository;
    private final LoggerUtility log = LoggerFactoryUtility.getLogger(this.getClass());

    /**
     * Captures the token generation process status as "GENERATION_IN_PROGRESS" and
     * saves the initial token details in the database.
     *
     * @param userId UUID
     */
    public TokenManagement saveInitialToken(UUID userId) {
        log.info("Saving initial token for userId: {}", userId);
        return tokenManagementRepository.save(TokenManagement.builder().tokenStatus(TokenStatus.GENERATION_IN_PROGRESS).userId(userId).remarks(TokenStatus.GENERATION_IN_PROGRESS.remarks).build());
    }

    public List<TokenManagement> getAll(){
        Iterable<TokenManagement> tokenManagementCaches = tokenManagementRepository.findAll();
        return StreamSupport.stream(tokenManagementCaches.spliterator(), false).toList();
    }
    /**
     * This method will check if token is valid and exists
     *
     * @param token String
     * @return boolean
     */
    public boolean isValidTokenExist(String token) {
        log.info("Checking if valid token exists for token: {}", token);
        return tokenManagementRepository.findByTokenAndIsValidTrue(token).isPresent();
    }

    /**
     * Saves the token in the DB
     *
     * @param tokenManagement List<TokenManagement>
     */
    public void saveToken(List<TokenManagement> tokenManagement) {
        log.info("Saving token");
        tokenManagementRepository.saveAll(tokenManagement);
    }

    /**
     * This method will find the user by ID and return data based on status and if Userid matches
     *
     * @param userId UUID
     * @return TokenManagement
     */
    public Optional<TokenManagement> findTokenByUserIdAndIsValidTrue(UUID userId) {
        log.info("Finding valid token for userId: {}", userId);
        return tokenManagementRepository.findTokenByUserIdAndIsValidTrue(userId);
    }

    /**
     * This method fetches the merchant user details  based on the provided userName,email or mobile number
     *
     * @param userName String
     * @return MerchantUserDto
     */
    public MerchantUserDto getMerchantUserDto(String userName) {
        log.info("Fetching merchant user details for userName: {}", userName);
        return merchantUserDao.getByUserNameOrEmailOrMobilePhoneAndStatus(userName, userName, userName, List.of(UserStatus.ACTIVE));
    }

    /**
     * This method fetches the merchant user details  based on the provided userName and status
     *
     * @param userName   String
     * @param userStatus List<UserStatus>
     * @return MerchantUserDto
     */
    public MerchantUserDto getMerchantUserDto(String userName, List<UserStatus> userStatus) {
        log.info("Fetching merchant user details for userName: {}, with user status: {}", userName, userStatus);
        return merchantUserDao.getByUserNameOrEmailOrMobilePhoneAndStatus(userName, userName, userName, userStatus);
    }

    /**
     * This method fetches the role name of a merchant user based on the provided role ID.
     *
     * @param roleId UUID
     * @return USER or name of the user's role
     */
    public String getMerchantUserRoleName(UUID roleId) {
        log.info("Fetching merchant user role name for roleId: {}", roleId);
        return userRolesRepository.findById(roleId).map(MerchantUserRole::getRole).orElse(USER);
    }

    /**
     * This method will update the user login status in the DB
     *
     * @param merchantUserDto MerchantUserDto
     * @param loginStatus     boolean
     */
    public int updateMerchantUserForLogin(MerchantUserDto merchantUserDto, boolean loginStatus) {
        log.info("Updating login status for userName: {}, loginStatus: {}", merchantUserDto.getUserName(), loginStatus);
        return merchantUserDao.updateMerchantUserForLogin(merchantUserDto, loginStatus);
    }

}




