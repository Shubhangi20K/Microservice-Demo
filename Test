@Component
@RequiredArgsConstructor
public class AdminDao {

    private static final LoggerUtility logger = LoggerFactoryUtility.getLogger(AdminDao.class);
    private final AdminServicesClient adminServicesClient;

    public MerchantInfoResponse getMerchantByMId(String mId) {
        logger.info("Fetching Merchant Information for mId: {}", mId);
        TransactionResponse<MerchantInfoResponse> response = adminServicesClient.getMerchantInfoByMId(mId);
        if (TransactionConstant.RESPONSE_SUCCESS == response.getStatus() && CollectionUtils.isNotEmpty(response.getData())) {
            logger.info("Successfully retrieved MerchantInfoResponse for mId: {}", mId);
            return response.getData().getFirst();
        }
        logger.error("Error in getMerchantByMId {} - Errors: {}", mId, response.getErrors());
        throw new TransactionException(TransactionErrorConstants.NOT_FOUND_ERROR_CODE, 
                MessageFormat.format(TransactionErrorConstants.NOT_FOUND_ERROR_MESSAGE, "MId"));
    }

    public boolean isValidCurrencyCode(String mId, String currencyCode) {
        logger.info("Validating currency code: {} for Merchant ID: {}", currencyCode, mId);
        CurrencyRequest currencyRequest = CurrencyRequest.builder().mId(mId).currencyCode(currencyCode).build();
        TransactionResponse<?> response = adminServicesClient.getCurrencyValidate(currencyRequest);
        boolean isValid = TransactionConstant.RESPONSE_SUCCESS == response.getStatus();
        logger.info("Currency validation result for mId: {} - currencyCode: {} - Valid: {}", mId, currencyCode, isValid);
        return isValid;
    }

    public MerchantRfcDetailsResponse getMerchantRFCDetails(String mId) {
        logger.info("Fetching RFC details for mId: {}", mId);
        TransactionResponse<MerchantRfcDetailsResponse> response = adminServicesClient.getMerchantRFCInfo(mId);
        if (TransactionConstant.RESPONSE_SUCCESS == response.getStatus() && CollectionUtils.isNotEmpty(response.getData())) {
            logger.info("Successfully retrieved MerchantRfcDetailsResponse for mId: {}", mId);
            return response.getData().getFirst();
        }
        logger.error("Error in getMerchantRFCDetails {} - Errors: {}", mId, response.getErrors());
        throw new TransactionException(TransactionErrorConstants.NOT_FOUND_ERROR_CODE, 
                MessageFormat.format(TransactionErrorConstants.NOT_FOUND_ERROR_MESSAGE, "MerchantRFCDetails"));
    }

    public Map<String, List<String>> getMerchantMultiAccount(String mId) {
        logger.info("Fetching multiple account details for mId: {}", mId);
        TransactionResponse<Map<String, List<String>>> response = adminServicesClient.getMultiAccountDetailsApi(mId);
        if (TransactionConstant.RESPONSE_SUCCESS == response.getStatus() && CollectionUtils.isNotEmpty(response.getData())) {
            logger.info("Successfully retrieved multiple accounts for mId: {}", mId);
            return response.getData().getFirst();
        }
        logger.error("Error in getMerchantMultiAccount {} - Errors: {}", mId, response.getErrors());
        throw new TransactionException(TransactionErrorConstants.NOT_FOUND_ERROR_CODE, 
                MessageFormat.format(TransactionErrorConstants.NOT_FOUND_ERROR_MESSAGE, "MerchantMultiAccount"));
    }

    public JsonNode getMerchantPayModes(String mId) {
        logger.info("Fetching pay modes for mId: {}", mId);
        TransactionResponse<JsonNode> response = adminServicesClient.getMerchantPayModeInfo(mId);
        if (TransactionConstant.RESPONSE_SUCCESS == response.getStatus() && CollectionUtils.isNotEmpty(response.getData())) {
            logger.info("Successfully retrieved pay modes for mId: {}", mId);
            return response.getData().getFirst().get("paymodes");
        }
        logger.error("Error in getMerchantPayModes {} - Errors: {}", mId, response.getErrors());
        throw new TransactionException(TransactionErrorConstants.NOT_FOUND_ERROR_CODE, 
                MessageFormat.format(TransactionErrorConstants.NOT_FOUND_ERROR_MESSAGE, "MerchantPayModes"));
    }

    public List<MerchantVolumeVelocityResponse> getMerchantVVLDetails(String mId) {
        logger.info("Fetching Merchant VVL details for mId: {}", mId);
        TransactionResponse<MerchantVolumeVelocityResponse> response = adminServicesClient.geVvlDetails(mId);
        if (TransactionConstant.RESPONSE_SUCCESS == response.getStatus() && CollectionUtils.isNotEmpty(response.getData())) {
            logger.info("Successfully retrieved VVL details for mId: {}", mId);
            return response.getData();
        }
        logger.error("Error in getMerchantVVLDetails {} - Errors: {}", mId, response.getErrors());
        throw new TransactionException(TransactionErrorConstants.NOT_FOUND_ERROR_CODE, 
                MessageFormat.format(TransactionErrorConstants.NOT_FOUND_ERROR_MESSAGE, "MerchantVVLDetails"));
    }

    public GatewayConfigDetailsResponse getGatewayConfigDetails(String mId, String gateWayMapId) {
        logger.info("Fetching Gateway Config Details for mId: {} and gateWayMapId: {}", mId, gateWayMapId);
        TransactionResponse<GatewayConfigDetailsResponse> response = adminServicesClient.getGatewayConfigDetails(mId, gateWayMapId);
        if (TransactionConstant.RESPONSE_SUCCESS == response.getStatus() && CollectionUtils.isNotEmpty(response.getData())) {
            logger.info("Successfully retrieved Gateway Config Details for mId: {}", mId);
            return response.getData().getFirst();
        }
        logger.error("Error in getGatewayConfigDetails {} - Errors: {}", mId, response.getErrors());
        throw new TransactionException(TransactionErrorConstants.NOT_FOUND_ERROR_CODE, 
                MessageFormat.format(TransactionErrorConstants.NOT_FOUND_ERROR_MESSAGE, "GatewayConfigDetails"));
    }

    public MerchantPricingResponse getValidMerchantPricingStructure(MerchantPricingRequest merchantPricingRequest) {
        logger.info("Fetching valid Merchant Pricing Structure for request: {}", merchantPricingRequest);
        TransactionResponse<MerchantPricingResponse> response = adminServicesClient.getMerchantPricingStructure(merchantPricingRequest);
        if (TransactionConstant.RESPONSE_SUCCESS == response.getStatus() && CollectionUtils.isNotEmpty(response.getData())) {
            MerchantPricingResponse merchantPricingResponse = response.getData().getFirst();
            if (ObjectUtils.isEmpty(merchantPricingResponse.getFeeProcessingFlag()) || 
                !merchantPricingResponse.getFeeProcessingFlag().equals(TransactionConstant.TRANSACTION_PROCESSING_FLAG_HYBRID)) {
                logger.warn("Invalid fee processing flag for MerchantPricingResponse: {}", merchantPricingResponse);
                throw new ValidationException(TransactionErrorConstants.NOT_FOUND_ERROR_CODE, 
                        MessageFormat.format(TransactionErrorConstants.NOT_FOUND_ERROR_MESSAGE, "Hybrid transaction processing flag"));
            }
            if (ObjectUtils.isEmpty(merchantPricingResponse.getBearableComponent()) || 
                !(merchantPricingResponse.getBearableComponent().equalsIgnoreCase(TransactionConstant.BEARABLE_COMPONENT_FEE) || 
                  merchantPricingResponse.getBearableComponent().equalsIgnoreCase(TransactionConstant.BEARABLE_COMPONENT_AMOUNT))) {
                logger.warn("Invalid bearable component for MerchantPricingResponse: {}", merchantPricingResponse);
                throw new ValidationException(TransactionErrorConstants.NOT_FOUND_ERROR_CODE, 
                        MessageFormat.format(TransactionErrorConstants.NOT_FOUND_ERROR_MESSAGE, "Valid bearable component"));
            }
            logger.info("Successfully retrieved Merchant Pricing Structure: {}", merchantPricingResponse);
            return merchantPricingResponse;
        }
        logger.error("Error in getMerchantPricingStructure - Errors: {}", response.getErrors());
        throw new TransactionException(TransactionErrorConstants.NOT_FOUND_ERROR_CODE, 
                MessageFormat.format(TransactionErrorConstants.NOT_FOUND_ERROR_MESSAGE, "Merchant Pricing information"));
    }

    public BinCheckResponse getBinCheckResponse(BinCheckRequest binCheckRequest) {
        logger.info("Fetching Bin Check Response for request: {}", binCheckRequest);
        TransactionResponse<BinCheckResponse> response = adminServicesClient.binCheckRequest(binCheckRequest);
        if (TransactionConstant.RESPONSE_SUCCESS == response.getStatus() && CollectionUtils.isNotEmpty(response.getData())) {
            logger.info("Successfully retrieved Bin Check Response.");
            return response.getData().getFirst();
        }
        logger.error("Error in getBinCheckResponse - Errors: {}", response.getErrors());
        throw new TransactionException(TransactionErrorConstants.NOT_FOUND_ERROR_CODE, 
                MessageFormat.format(TransactionErrorConstants.NOT_FOUND_ERROR_MESSAGE, "CardBinCheck"));
    }
}
