Here's a JUnit test case for the validatedAssignedRole method using Mockito to mock dependencies:

Assumptions:

merchantUserDao.getUserRoleName(role) returns a role name.

EPayIdentityUtil.getUserPrincipal().getUserRole() returns a list with a user role.

errorDtoList is a list where errors are added.

throwIfErrors() throws an exception if errors exist.



---

JUnit Test Case:

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import java.util.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class PasswordServiceTest {

    @InjectMocks
    private PasswordService passwordService; // Assuming the method is in this service

    @Mock
    private MerchantUserDao merchantUserDao;

    @Mock
    private EPayIdentityUtil ePayIdentityUtil;

    private List<ErrorDto> errorDtoList;

    @BeforeEach
    void setUp() {
        errorDtoList = new ArrayList<>();
        passwordService.errorDtoList = errorDtoList; // Assuming it's accessible
    }

    @Test
    void testValidatedAssignedRole_AdminCannotAssignSuperAdmin() {
        UUID roleId = UUID.randomUUID();

        // Mocking behavior
        when(ePayIdentityUtil.getUserPrincipal()).thenReturn(mock(UserPrincipal.class));
        when(ePayIdentityUtil.getUserPrincipal().getUserRole()).thenReturn(Collections.singletonList("ADMIN"));
        when(merchantUserDao.getUserRoleName(roleId)).thenReturn("SUPER_ADMIN");

        // Invoke method
        Exception exception = assertThrows(RuntimeException.class, () -> passwordService.validatedAssignedRole(roleId));

        // Assertions
        assertFalse(errorDtoList.isEmpty());
        assertEquals(ErrorConstants.INVALID_ERROR_CODE, errorDtoList.get(0).getErrorCode());
        assertTrue(exception.getMessage().contains("INVALID_ERROR_MESSAGE"));
    }

    @Test
    void testValidatedAssignedRole_UserCannotAssignOtherThanUser() {
        UUID roleId = UUID.randomUUID();

        // Mocking behavior
        when(ePayIdentityUtil.getUserPrincipal()).thenReturn(mock(UserPrincipal.class));
        when(ePayIdentityUtil.getUserPrincipal().getUserRole()).thenReturn(Collections.singletonList("USER"));
        when(merchantUserDao.getUserRoleName(roleId)).thenReturn("ADMIN");

        // Invoke method
        Exception exception = assertThrows(RuntimeException.class, () -> passwordService.validatedAssignedRole(roleId));

        // Assertions
        assertFalse(errorDtoList.isEmpty());
        assertEquals(ErrorConstants.INVALID_ERROR_CODE, errorDtoList.get(0).getErrorCode());
        assertTrue(exception.getMessage().contains("INVALID_ERROR_MESSAGE"));
    }
}


---

Key Points:

1. Mocks Dependencies:

merchantUserDao to return role names.

EPayIdentityUtil.getUserPrincipal().getUserRole() to return current user role.



2. Tests Two Scenarios:

Admin cannot assign a SUPER_ADMIN role.

User cannot assign a non-USER role.



3. Assertions:

Ensures errorDtoList gets populated.

Asserts expected error codes and messages.

Checks if throwIfErrors() raises an exception.




Would you like to cover additional cases?







void validatedAssignedRole(UUID role) {
        MerchantUserRoles loggedInUserRole = MerchantUserRoles.getRole(EPayIdentityUtil.getUserPrincipal().getUserRole().getFirst());
        MerchantUserRoles userRoleName = MerchantUserRoles.getRole(merchantUserDao.getUserRoleName(role));
        if (MerchantUserRoles.ADMIN == loggedInUserRole && MerchantUserRoles.SUPER_ADMIN.equals(userRoleName)) {
            errorDtoList.add(ErrorDto.builder().errorCode(ErrorConstants.INVALID_ERROR_CODE).errorMessage(MessageFormat.format(ErrorConstants.INVALID_ERROR_MESSAGE, ROLE, ADMIN_AND_USER)).build());
        } else if (MerchantUserRoles.USER == loggedInUserRole && !MerchantUserRoles.USER.equals(userRoleName)) {
            errorDtoList.add(ErrorDto.builder().errorCode(ErrorConstants.INVALID_ERROR_CODE).errorMessage(MessageFormat.format(ErrorConstants.INVALID_ERROR_MESSAGE, ROLE, TO_BE_ASSIGNED_ROLE_ARE_USER)).build());
        }
        throwIfErrors();
    }
