package com.epay.merchant.dao;

import com.epay.merchant.config.MerchantConfig;
import com.epay.merchant.dto.MerchantBankAccountDto;
import com.epay.merchant.dto.MerchantInfoDto;
import com.epay.merchant.entity.MerchantBankAccount;
import com.epay.merchant.entity.MerchantInfo;
import com.epay.merchant.exception.MerchantException;
import com.epay.merchant.mapper.MerchantMapper;
import com.epay.merchant.repository.MerchantBankAccountRepository;
import com.epay.merchant.util.ErrorConstants;
import com.epay.merchant.util.enums.AccountStatus;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Repository;

import java.text.MessageFormat;
import java.util.Optional;

import static com.epay.merchant.util.EncryptionDecryptionUtil.decryptValue;
import static com.epay.merchant.util.MaskingUtil.maskAccountNumber;

/**
 * Class Name: MerchantInfoDao
 * *
 * Description:
 * This class handles operations related to merchant bank account management, including saving, updating, and retrieving merchant bank accounts.
 * It also includes logic for account number masking, checking account uniqueness, and generating alerts for bank account approval.
 * <p>
 * Author: Subhra Goswami
 * <p>
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * <p>
 * Version:1.0
 */
@Repository
@RequiredArgsConstructor
public class MerchantBankDao {

    private final MerchantBankAccountRepository merchantBankAccountRepository;
    private final AlertDao alertDao;
    private final MerchantMapper mapper;
    private final MerchantConfig merchantConfig;

    /**
     * Saves or updates a merchant bank account.
     * This method maps the provided DTO to an entity, decrypts and masks the account number,
     * checks whether the account is the primary one, and then saves it to the database.
     *
     * @param merchantBankAccountDto The DTO representing the merchant bank account to be saved.
     * @param isCreate               Indicates if the operation is a creation (true) or update (false).
     */
    @Transactional
    public void saveMerchantBankAccount(MerchantBankAccountDto merchantBankAccountDto, boolean isCreate) {
        MerchantBankAccount merchantBankAccount = mapper.mapDtoToEntity(merchantBankAccountDto);
        //Before masking decrypt the account Number
        String accountNumber = decryptValue(merchantConfig.getDecryptionKey(), merchantBankAccountDto.getAccountNumber());
        //Masking accountNumber
        merchantBankAccount.setAccountNumberMasked(maskAccountNumber(accountNumber));
        checkPrimaryAccountAndUpdate(merchantBankAccount);
        saveMerchantBankAccount(isCreate, merchantBankAccount);
    }

    /**
     * Retrieves a list of merchant bank accounts for a given merchant ID (mId).
     * The list is paginated using the provided Pageable object.
     *
     * @param mId      The merchant ID whose bank accounts are to be retrieved.
     * @param pageable The Pageable object for pagination.
     * @return A list of MerchantBankAccountDto objects representing the merchant's bank accounts.
     */
    public Page<MerchantBankAccountDto> getMerchantBankAccountByMId(String mId, Pageable pageable) {
        Page<MerchantBankAccount> merchantBankAccounts = merchantBankAccountRepository.findAllBymId(mId, pageable);
        return merchantBankAccounts.map(this::convertEntityToDTO);
    }

    /**
     * Checks if a merchant bank account exists based on the unique account identifier.
     *
     * @param accountUniqueIdentifier The unique identifier of the merchant bank account.
     * @return True if the account exists, otherwise false.
     */
    public boolean isExistByAccountUniqueIdentifier(String accountUniqueIdentifier) {
        return merchantBankAccountRepository.existsByAccountUniqueIdentifier(accountUniqueIdentifier);
    }

    /**
     * Checks if a merchant bank account exists based on the account number.
     *
     * @param accountNumber The account number of the merchant bank account.
     * @return True if the account exists, otherwise false.
     */
    public boolean isExistByAccountNumber(String accountNumber) {
        return merchantBankAccountRepository.existsByAccountNumber(accountNumber);
    }

    /**
     * Retrieves a merchant bank account by its unique identifier and returns it as a DTO.
     *
     * @param accountUniqueIdentifier The unique identifier of the bank account.
     * @return A MerchantBankAccountDto object representing the bank account.
     */
    public MerchantBankAccountDto getAccountByAccountUniqueIdentifier(String accountUniqueIdentifier) {
        MerchantBankAccount merchantBankAccount = getMerchantBankAccount(accountUniqueIdentifier);
        return mapper.mapEntityToDto(merchantBankAccount);
    }

    /**
     * Approves or rejects a merchant bank account, updating its status accordingly.
     * If rejected, the rejection reason is provided. It also generates an alert for bank account approval.
     *
     * @param mId                     The merchant ID associated with the bank account.
     * @param accountUniqueIdentifier The unique identifier of the bank account.
     * @param isAccountApproved       Indicates if the account is approved (true) or rejected (false).
     * @param remarks                 The reason for rejection if the account is not approved.
     */
    @Transactional
    public void saveMerchantBankAccount(String mId, String accountUniqueIdentifier, boolean isAccountApproved, String remarks) {
        MerchantBankAccount merchantBankAccount = getAccountByMidAndUniqueIdentifier(mId, accountUniqueIdentifier);
        merchantBankAccount.setApproved(isAccountApproved);
        if (!isAccountApproved) {
            merchantBankAccount.setRejectedReason(remarks);
            merchantBankAccount.setStatus(AccountStatus.REJECTED);
        } else {
            merchantBankAccount.setStatus(AccountStatus.APPROVED);
        }
        merchantBankAccountRepository.save(merchantBankAccount);
        alertDao.generateAlertForBankAccountApproval(mId, merchantBankAccount.getAccountHolderName());
    }

    /**
     * Retrieves a merchant bank account by the merchant ID and unique account identifier.
     * Throws an exception if the account is not found.
     *
     * @param mid              The merchant ID associated with the bank account.
     * @param uniqueIdentifier The unique identifier of the bank account.
     * @return A MerchantBankAccount object representing the bank account.
     * @throws MerchantException If the account is not found.
     */
    public MerchantBankAccount getAccountByMidAndUniqueIdentifier(String mid, String uniqueIdentifier) {
        return merchantBankAccountRepository.findBymIdAndAccountUniqueIdentifier(mid, uniqueIdentifier).orElseThrow(() -> new MerchantException(ErrorConstants.NOT_FOUND_ERROR_CODE, MessageFormat.format(ErrorConstants.NOT_FOUND_ERROR_MESSAGE, "Account Information")));
    }

    /**
     * Retrieves a merchant bank account by its unique identifier.
     * Throws an exception if the account is not found.
     *
     * @param accountUniqueIdentifier The unique identifier of the bank account.
     * @return A MerchantBankAccount object representing the bank account.
     * @throws MerchantException If the account is not found.
     */
    private MerchantBankAccount getMerchantBankAccount(String accountUniqueIdentifier) {
        return merchantBankAccountRepository.findByAccountUniqueIdentifier(accountUniqueIdentifier).orElseThrow(() -> new MerchantException(ErrorConstants.NOT_FOUND_ERROR_CODE, MessageFormat.format(ErrorConstants.NOT_FOUND_ERROR_MESSAGE, "Account Information")));
    }

    /**
     * Converts a MerchantInfo entity to a MerchantInfoDto.
     *
     * @param merchantInfo The MerchantInfo entity to convert.
     * @return A MerchantInfoDto object representing the merchant information.
     */
    private MerchantInfoDto convertEntityToDTO(MerchantInfo merchantInfo) {
        return mapper.mapMerchantInfoEntityToMerchantInfoDto(merchantInfo);
    }

    /**
     * Saves a merchant bank account to the database, either creating a new record or updating an existing one.
     * Sets the account status to "APPROVAL_PENDING" and updates any existing account if necessary.
     *
     * @param isCreate            Indicates whether the account is being created (true) or updated (false).
     * @param merchantBankAccount The MerchantBankAccount entity to save.
     */
    protected void saveMerchantBankAccount(boolean isCreate, MerchantBankAccount merchantBankAccount) {
        merchantBankAccount.setStatus(AccountStatus.APPROVAL_PENDING);
        if (!isCreate) {
            setMerchantAccountDBValueOnUpdate(merchantBankAccount);
        }
        merchantBankAccountRepository.save(merchantBankAccount);
    }

    /**
     * Checks if the given bank account is the primary account for the merchant.
     * If it is, the previous primary account is updated to no longer be primary.
     *
     * @param merchantBankAccount The MerchantBankAccount entity to check and update.
     */
    protected void checkPrimaryAccountAndUpdate(MerchantBankAccount merchantBankAccount) {
        if (merchantBankAccount.isPrimary()) {
            Optional<MerchantBankAccount> merchantPrimaryBankAccount = merchantBankAccountRepository.findBymIdAndIsPrimaryTrue(merchantBankAccount.getMId());
            if (merchantPrimaryBankAccount.isPresent()) {
                merchantPrimaryBankAccount.get().setPrimary(false);
                merchantBankAccountRepository.save(merchantPrimaryBankAccount.get());
            }
        }
    }


    /**
     * Updates the database values of a merchant bank account when updating an existing account.
     * The method ensures that the values (ID, creation date, and creator) are preserved.
     *
     * @param merchantBankAccount The MerchantBankAccount entity to update.
     */
    protected void setMerchantAccountDBValueOnUpdate(MerchantBankAccount merchantBankAccount) {
        MerchantBankAccount dbMerchantBankAccount = getMerchantBankAccount(merchantBankAccount.getAccountUniqueIdentifier());
        merchantBankAccount.setId(dbMerchantBankAccount.getId());
        merchantBankAccount.setCreatedAt(dbMerchantBankAccount.getCreatedAt());
        merchantBankAccount.setCreatedBy(dbMerchantBankAccount.getCreatedBy());
    }

    /**
     * Convert MerchantInfo Entity to MerchantInfoDto
     * @param merchantBankAccount MerchantBankAccount
     * @return  MerchantBankAccountDto
     */
    private MerchantBankAccountDto convertEntityToDTO(MerchantBankAccount merchantBankAccount) {
        return mapper.mapEntityToDto(merchantBankAccount);
    }


}
public interface MerchantBankAccountRepository extends JpaRepository<MerchantBankAccount, UUID> {

    boolean existsByAccountUniqueIdentifier(String accountUniqueIdentifier);

    boolean existsByAccountNumber(String accountNumber);

    Optional<MerchantBankAccount> findBymIdAndIsPrimaryTrue(String mId);

    Optional<MerchantBankAccount> findByAccountUniqueIdentifier(String accountUniqueIdentifier);

    Page<MerchantBankAccount> findAllBymId(String mId, Pageable pageable);

    Optional<MerchantBankAccount> findBymIdAndAccountUniqueIdentifier(String mId, String accountUniqueIdentifier);

}
MerchantBankAccount extends AuditEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;
    @Column(name = "mid")
    private String mId;
    private String accountHolderName;
    private String accountUniqueIdentifier;
    @Enumerated(EnumType.STRING)
    private AccountType accountType;
    private String accountNumber;
    private String accountNumberMasked;
    private String bankName;
    private String branchName;
    private String ifscCode;
    private boolean isApproved;
    private boolean isPrimary;
    private String approvedRejectedBy;
    private String rejectedReason;
    private String approvedRejectedOn;
    @Enumerated(EnumType.STRING)
    private AccountStatus status;

    @PrePersist
    @PreUpdate
    public void setEntityNameForRevision(){
        AuditRevisionListener.setEntityName(this.getClass().getSimpleName());
    }

package com.epay.merchant.dao;

import com.epay.merchant.config.MerchantConfig;
import com.epay.merchant.dto.MerchantBankAccountDto;
import com.epay.merchant.entity.MerchantBankAccount;
import com.epay.merchant.exception.MerchantException;
import com.epay.merchant.mapper.MerchantMapper;
import com.epay.merchant.repository.MerchantBankAccountRepository;
import com.epay.merchant.util.EncryptionDecryptionUtil;
import com.epay.merchant.util.ErrorConstants;
import com.epay.merchant.util.MerchantBankAccountDtoBuilder;
import com.epay.merchant.util.enums.AccountStatus;
import com.sbi.epay.logging.utility.LoggerUtility;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mapstruct.factory.Mappers;
import org.mockito.*;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;

import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class MerchantBankDaoTest {

    @Mock
    private MerchantBankAccountRepository merchantBankAccountRepository;

    @Mock
    private AlertDao alertDao;

    @Mock
    private MerchantMapper mapper;

    @Mock
    private MerchantConfig merchantConfig;

    @InjectMocks
    private MerchantBankDao merchantBankDao;

    private MerchantBankAccountDto mockDto;
    private MerchantBankAccount mockEntity;

    MerchantBankAccountDto merchantBankAccountDto;


    @Mock
    private MerchantMapper merchantMapper;




    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);

        mockDto = new MerchantBankAccountDto();
        mockDto.setAccountUniqueIdentifier("12345");
        mockDto.setMId("merchantId");
        mockDto.setAccountNumber("9876543210");

        mockEntity = new MerchantBankAccount();
        mockEntity.setAccountUniqueIdentifier("12345");
        mockEntity.setMId("merchantId");
        mockEntity.setAccountNumber("9876543210");
        mockEntity.setStatus(AccountStatus.APPROVAL_PENDING);
        when(merchantConfig.getDecryptionKey()).thenReturn("ABCZ5feKr16Td3XSpVywqXlwRNfSy9Gtis04WqEbD/0=");

    }
    MerchantMapper mapperReal = Mappers.getMapper(MerchantMapper.class);




    @Test
    void isExistByAccountUniqueIdentifier_shouldReturnTrue_whenAccountExists() {
        // Arrange
        when(merchantBankAccountRepository.existsByAccountUniqueIdentifier("12345")).thenReturn(true);

        // Act
        boolean result = merchantBankDao.isExistByAccountUniqueIdentifier("12345");

        // Assert
        assertTrue(result);
    }

    @Test
    void getAccountByMidAndUniqueIdentifier_shouldThrowMerchantException_whenAccountNotFound() {
        // Arrange
        when(merchantBankAccountRepository.findBymIdAndAccountUniqueIdentifier("merchantId", "12345"))
                .thenReturn(Optional.empty());

        // Act & Assert
        MerchantException exception = assertThrows(MerchantException.class, () ->
                merchantBankDao.getAccountByMidAndUniqueIdentifier("merchantId", "12345")
        );
        assertEquals(ErrorConstants.NOT_FOUND_ERROR_CODE, exception.getErrorCode());
    }


}


I've this test  class it's covering 25% please help me to write more
