package com.sbi.epay.encryptdecrypt.service;


import com.sbi.epay.encryptdecrypt.constant.EncryptionDecryptionConstants;
import com.sbi.epay.encryptdecrypt.exception.EncryptionDecryptionException;
import com.sbi.epay.encryptdecrypt.util.enums.EncryptionDecryptionAlgo;
import com.sbi.epay.encryptdecrypt.util.enums.GCMIvLength;
import com.sbi.epay.encryptdecrypt.util.enums.GCMTagLength;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import jdk.jfr.Description;
import lombok.NonNull;

import javax.crypto.*;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;


/**
 * Class Name: DecryptionService
 * *
 * Description:This class will be used for  decryption using AES-GSM-NOPADDING algorithm
 * *
 * Author: V1018212(Hrishikesh Pandirakar)
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * *
 * Version:1.0
 */
@Description("This class will be used for  decryption using AES-GSM-NOPADDING algorithm")
public class DecryptionService {
    private static final LoggerUtility log = LoggerFactoryUtility.getLogger(DecryptionService.class);

    /**
     * This method will be used for decryption of Keys .
     *
     * @param key          the SecretKey by which we want use for decrypt the given text
     * @param value        String which we want to decrypt
     * @param algorithm    EncryptionDecryptionAlgo algorithm
     * @param gcmIvLength  algorithm iv length
     * @param gcmTagLength algorithm tag length
     * @return the String of original encoded KEK
     */
    public static String decryptValueByStringKey(String key, String value, @NonNull EncryptionDecryptionAlgo algorithm, @NonNull GCMIvLength gcmIvLength, @NonNull GCMTagLength gcmTagLength) throws EncryptionDecryptionException {
        log.info("Decryption Service ::  key : {}, value : {}, algorithm : {}, gcmIvLength : {}, gcmTagLength : {}", key, value, algorithm, gcmIvLength, gcmTagLength);
        return decryptValueBySecretKey(decodedValue(key), value, algorithm, gcmIvLength, gcmTagLength);
    }

    /**
     * This method will be used for decryption of Value .
     *
     * @param value        String which we want to decrypt
     * @param key          the SecretKey by which we want use for decrypt the given text
     * @param algorithm    EncryptionDecryptionAlgo algorithm
     * @param gcmIvLength  algorithm iv length
     * @param gcmTagLength algorithm tag length
     * @return the String of original encoded KEK
     */
    public static String decryptValueBySecretKey(@NonNull SecretKey key, @NonNull String value, @NonNull EncryptionDecryptionAlgo algorithm, @NonNull GCMIvLength gcmIvLength, @NonNull GCMTagLength gcmTagLength) throws EncryptionDecryptionException {
        log.info("Decryption Service ::  key : {}, value : {}, algorithm : {}, gcmIvLength : {}, gcmTagLength : {}", key, value, algorithm, gcmIvLength, gcmTagLength);
        try {
            return decryptValue(key, value, algorithm, gcmIvLength, gcmTagLength);
        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException |
                 InvalidAlgorithmParameterException | IllegalArgumentException | UnsupportedOperationException |
                 IllegalStateException | IllegalBlockSizeException | BadPaddingException e) {
            log.error("DecryptionService :: decrypt {}", e);
            throw new EncryptionDecryptionException(EncryptionDecryptionConstants.GENERIC_ERROR_CODE, EncryptionDecryptionConstants.GENERIC_ERROR_MESSAGE);
        }
    }
____________&

package com.sbi.epay.encryptdecrypt.service;

import com.sbi.epay.encryptdecrypt.constant.EncryptionDecryptionConstants;
import com.sbi.epay.encryptdecrypt.exception.EncryptionDecryptionException;
import com.sbi.epay.encryptdecrypt.util.enums.EncryptionDecryptionAlgo;
import com.sbi.epay.encryptdecrypt.util.enums.GCMIvLength;
import com.sbi.epay.encryptdecrypt.util.enums.GCMTagLength;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoExtension;

import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.util.Base64;

import static org.junit.jupiter.api.Assertions.*;

@ExtendWith(MockitoExtension.class)
class DecryptionServiceTest {

    private static final String SAMPLE_KEY = "0123456789abcdef"; // Example 128-bit key
    private static final String SAMPLE_ENCRYPTED_VALUE = "encryptedText"; // Example encrypted text

    private SecretKey secretKey;

    @BeforeEach
    void setUp() {
        byte[] decodedKey = Base64.getDecoder().decode(Base64.getEncoder().encodeToString(SAMPLE_KEY.getBytes()));
        secretKey = new SecretKeySpec(decodedKey, 0, decodedKey.length, "AES");
    }

    @Test
    void testDecryptValueByStringKey_ShouldThrowException() {
        assertThrows(EncryptionDecryptionException.class, () ->
                DecryptionService.decryptValueByStringKey(SAMPLE_KEY, SAMPLE_ENCRYPTED_VALUE, 
                        EncryptionDecryptionAlgo.AES_GCM_NOPADDING, GCMIvLength.BIT_96, GCMTagLength.BIT_128)
        );
    }

    @Test
    void testDecryptValueBySecretKey_ShouldThrowException() {
        assertThrows(EncryptionDecryptionException.class, () ->
                DecryptionService.decryptValueBySecretKey(secretKey, SAMPLE_ENCRYPTED_VALUE, 
                        EncryptionDecryptionAlgo.AES_GCM_NOPADDING, GCMIvLength.BIT_96, GCMTagLength.BIT_128)
        );
    }
}
