package com.epay.transaction.validator;

import com.epay.transaction.config.TransactionConfig;
import com.epay.transaction.dto.MerchantPaymentOrderDto;
import com.epay.transaction.exceptions.TransactionException;
import com.epay.transaction.model.request.RefundBookRequest;
import com.epay.transaction.model.request.RefundSearchRequest;
import com.epay.transaction.util.DateTimeUtils;
import com.epay.transaction.util.TransactionConstant;
import com.epay.transaction.util.enums.RefundType;
import com.epay.transaction.util.enums.TransactionStatus;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import lombok.RequiredArgsConstructor;
import org.apache.commons.lang3.ObjectUtils;
import org.springframework.stereotype.Component;
import java.text.MessageFormat;
import java.util.*;

import static com.epay.transaction.util.TransactionErrorConstants.*;

/**
 * Class Name: RefundValidator
 * *
 * Description: Validator class for refund booking and searching
 * *
 * Author: NIRMAL GURJAR
 * <p>
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * *
 * Version:1.0
 */
@Component
@RequiredArgsConstructor
public class RefundValidator extends BaseValidator {

    private final LoggerUtility logger = LoggerFactoryUtility.getLogger(this.getClass());

    /**
     * Validate business rules for refund booking
     *
     * @param refundBookRequest       RefundBookRequest
     * @param merchantPaymentOrderDto refundBookRequest
     */
    public void validateBusinessRules(RefundBookRequest refundBookRequest, MerchantPaymentOrderDto merchantPaymentOrderDto) {
        logger.info("Inside validateBusinessRules for atrn: {}", refundBookRequest.getAtrnNumber());

        //Step-1: Check transaction status should be only SUCCESS/SETTLED
        if (!TransactionStatus.SUCCESS.equals(merchantPaymentOrderDto.getTransactionStatus()) && !TransactionStatus.SETTLED.equals(merchantPaymentOrderDto.getTransactionStatus())) {
            logger.debug("Invalid transaction status: {}", merchantPaymentOrderDto.getTransactionStatus());
            throw new TransactionException(INVALID_ERROR_CODE, MessageFormat.format(INVALID_ERROR_MESSAGE, MERCHANT_ORDER_PAYMENT_STATUS, MERCHANT_ORDR_PAYMENT_ST_NOT_VALID_AGAINST_ATRN));
        }

        //Step-2: check if it is first refund request, then update available refund amount
        if (ObjectUtils.isEmpty(merchantPaymentOrderDto.getRefundStatus())) {
            logger.debug("First refund request for atrn: {}", refundBookRequest.getAtrnNumber());
            merchantPaymentOrderDto.setAvailableRefundAmount(merchantPaymentOrderDto.getOrderAmount());
        }

        //Step-3: Check amount should not be more than available refund amount
        if (merchantPaymentOrderDto.getAvailableRefundAmount().compareTo(refundBookRequest.getRefundAmount()) < 0) {
            logger.debug("Available refund amount is less than requested amount");
            throw new TransactionException(INVALID_ERROR_CODE, MessageFormat.format(INVALID_ERROR_MESSAGE, REFUND_AMOUNT, REFUND_AMNT_MORE_THAN_AVAILABLE_AMNT_ERR_MSG));
        }

        //Step-4: Validate and get refund type throws exception if invalid refund type is passed
        RefundType refundType = RefundType.getRefundType(refundBookRequest.getRefundType());

        //Step-7: If refund type is full then match the amount with full available refund amount
        if (RefundType.FULL.equals(refundType) && merchantPaymentOrderDto.getAvailableRefundAmount().compareTo(refundBookRequest.getRefundAmount()) != 0) {
            logger.debug("Available refund amount does not match with requested amount for full refund request type");
            throw new TransactionException(INVALID_ERROR_CODE, MessageFormat.format(INVALID_ERROR_MESSAGE, REFUND_AMOUNT, FULL_REFUND_AMOUNT_MIS_MATCH));
        }

        //Step-8: If refund type is partial then match the amount with full available refund amount
        if (RefundType.PARTIAL.equals(refundType) && merchantPaymentOrderDto.getAvailableRefundAmount().compareTo(refundBookRequest.getRefundAmount()) == 0) {
            logger.debug("Request amount should be less than available refund amount for partial refund request type");
            throw new TransactionException(INVALID_ERROR_CODE, MessageFormat.format(INVALID_ERROR_MESSAGE, REFUND_AMOUNT, "Refund amount should be less than available refund amount for partial refund request type."));
        }
    }

    /**
     * Validate refund book request for basic validations
     *
     * @param refundBookRequest RefundBookRequest
     */
    public void validateRefundRequest(RefundBookRequest refundBookRequest) {
        errorDtoList = new ArrayList<>();
        logger.info("validation started for refundBookRequest : {}", refundBookRequest);
        validateMandatoryFields(refundBookRequest);
        validateFieldsValue(refundBookRequest);
    }

    /**
     * Validate mandatory fields for refund book request
     *
     * @param refundBookRequest RefundBookRequest
     */
    protected void validateMandatoryFields(RefundBookRequest refundBookRequest) {
        checkMandatoryField(refundBookRequest.getRefundType(), "Refund type");
        checkMandatoryField(refundBookRequest.getRefundAmount(), "RefundAmount");
        checkMandatoryField(refundBookRequest.getAtrnNumber(), "ATRN");
        throwIfErrors();
    }

    /**
     * Validate fields value for refund book request
     *
     * @param refundBookRequest RefundBookRequest
     */
    protected void validateFieldsValue(RefundBookRequest refundBookRequest) {
        logger.info("Inside validateFieldsValue for atrn: {}", refundBookRequest.getAtrnNumber());
        RefundType.getRefundType(refundBookRequest.getRefundType());
        validateRemark(refundBookRequest.getRemark());
        validateAmount(refundBookRequest.getRefundAmount(), "RefundAmount");
        checkForLeadingTrailingAndSingleSpace(refundBookRequest.getAtrnNumber(),"ATRN");
        checkForLeadingTrailingAndSingleSpace(refundBookRequest.getRemark(),"Remark" );
        throwIfErrors();
    }

    /**
     * Validate comment for refund book request
     *
     * @param comment String
     */
    protected void validateRemark(String comment) {
        validateFieldLength(comment, TransactionConstant.COMMENT_LENGTH, COMMENT);
        throwIfErrors();
        validateFieldWithRegex(comment, TransactionConstant.COMMENT_REGEX, COMMENT, INVALID_COMMENT);
        throwIfErrors();
    }

    /**
     * Validate refund search request
     *
     * @param refundSearchRequest RefundSearchRequest
     */
    public void validateRefundSearchRequest(RefundSearchRequest refundSearchRequest) {
        logger.info("Inside validateRefundDetailRequest for mid: {}", refundSearchRequest.getMId());
        errorDtoList = new ArrayList<>();
        validateMandatoryFields(refundSearchRequest);
        validateFieldsValue(refundSearchRequest);
    }

    /**
     * Validate mandatory fields for refund search request
     *
     * @param refundSearchRequest RefundSearchRequest
     */
    protected void validateMandatoryFields(RefundSearchRequest refundSearchRequest) {
        logger.info("Inside refundDetailRequest for refundSearchRequest: {}", refundSearchRequest);
        checkMandatoryField(refundSearchRequest.getMId(), "MId");
        throwIfErrors();
    }

    /**
     * Validate  field values for refund search request
     *
     * @param refundSearchRequest RefundSearchRequest
     */
    protected void validateFieldsValue(RefundSearchRequest refundSearchRequest) {

        logger.info("Inside validateFieldsValue for mid: {}", refundSearchRequest.getMId());

        //Step-1: check if valid from date is passed
        if (ObjectUtils.isNotEmpty(refundSearchRequest.getFrom())) {
            validateDate(refundSearchRequest.getFrom(), "From date");
        }
        //Step-2: check if valid to date is passed
        if (ObjectUtils.isNotEmpty(refundSearchRequest.getTo())) {
            validateDate(refundSearchRequest.getTo(), "To date");
        }
        throwIfErrors();

        //Step-3: if both from and to date is passed then check from date <= to date
        if (ObjectUtils.isNotEmpty(refundSearchRequest.getFrom()) && ObjectUtils.isNotEmpty(refundSearchRequest.getTo())) {
            validateFromToDate(refundSearchRequest.getFrom(), refundSearchRequest.getTo());
        }
        throwIfErrors();

        //Step-4: check for leading trailing single space
        checkForLeadingTrailingAndSingleSpace(refundSearchRequest);
    }

    /**
     * Validate  field values for leading trailing space for refund search request
     *
     * @param refundSearchRequest RefundSearchRequest
     */
    private void checkForLeadingTrailingAndSingleSpace(RefundSearchRequest refundSearchRequest) {

        logger.info("Inside checkForLeadingAndSingleSpace for mid: {}", refundSearchRequest.getMId());

        checkForLeadingTrailingAndSingleSpace(refundSearchRequest.getAtrnNumber(),"atrnNumber");
        checkForLeadingTrailingAndSingleSpace(refundSearchRequest.getArrnNumber(),"arrnNumber");
        checkForLeadingTrailingAndSingleSpace( refundSearchRequest.getSbiOrderRefNumber(),"sbiOrderRefNumber");
        checkForLeadingTrailingAndSingleSpace(refundSearchRequest.getRefundStatus(),"refundStatus");
        checkForLeadingTrailingAndSingleSpace(refundSearchRequest.getRefundType(),"refundType");

        throwIfErrors();
    }

    /**
     * Validate date for refund search request
     *
     * @param dateTimeMillis dateTimeMillis
     * @param fieldName      String
     */
    protected void validateDate(Long dateTimeMillis, String fieldName) {
        logger.info("Inside validateDate from dateTimeMillis: {} and fieldName :{}", dateTimeMillis, fieldName);
        if (dateTimeMillis > DateTimeUtils.getCurrentTimeInMills()) {
            logger.debug("Invalid date for dateTimeMillis: {} and fieldName :{}", dateTimeMillis, fieldName);
            addError(fieldName, INVALID_ERROR_CODE, "Date can not be more than current date.");
        }

    }

    /**
     * Validate from date for refund search request
     *
     * @param fromDateMillis Long
     * @param toDateMillis   Long
     */
    protected void validateFromToDate(Long fromDateMillis, Long toDateMillis) {
        logger.info("Inside validateFromToDate from date: {} and to date:{}", fromDateMillis, toDateMillis);
        if (fromDateMillis > toDateMillis) {
            logger.debug("From date can not be greater than to date for from date: {} and to date:{}", fromDateMillis, toDateMillis);
            addError(INVALID_ERROR_CODE, "From date can not be greater than to date");
        }
    }

}
