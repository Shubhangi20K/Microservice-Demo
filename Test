package com.epay.transaction.dao;

import com.epay.transaction.dto.MerchantPaymentOrderDto;
import com.epay.transaction.entity.MerchantOrderPayment;
import com.epay.transaction.exceptions.TransactionException;
import com.epay.transaction.mapper.MerchantOrderPaymentMapper;
import com.epay.transaction.model.request.MarkTransactionFailRequest;
import com.epay.transaction.model.request.MerchantOrderPaymentSearchRequest;
import com.epay.transaction.model.response.MerchantOrderResponse;
import com.epay.transaction.repository.MerchantOrderPaymentRepository;
import com.epay.transaction.specification.TransactionSpecification;
import com.epay.transaction.util.EPayIdentityUtil;
import com.epay.transaction.util.TransactionErrorConstants;
import com.epay.transaction.util.enums.PaymentStatus;
import com.epay.transaction.util.enums.TransactionStatus;
import com.sbi.epay.authentication.providers.EPayTokenProvider;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import lombok.RequiredArgsConstructor;
import org.apache.commons.lang3.StringUtils;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Component;

import java.text.MessageFormat;
import java.util.List;

@Component
@RequiredArgsConstructor
public class MerchantOrderPaymentDao {

    private final LoggerUtility logger = LoggerFactoryUtility.getLogger(this.getClass());

    private final MerchantOrderPaymentRepository merchantOrderPaymentRepository;
    private final MerchantOrderPaymentMapper merchantOrderPaymentMapper;
    private final EPayTokenProvider ePayTokenProvider;
    private final TokenDao tokenDao;

    public String getEncryptedAESKey() {
        return tokenDao.getEncryptionAESKey(ePayTokenProvider.getToken());
    }


    public MerchantPaymentOrderDto save(MerchantPaymentOrderDto merchantPaymentOrderDto) {
        MerchantOrderPayment merchantOrderPayment = merchantOrderPaymentMapper.dtoToEntity(merchantPaymentOrderDto);
        MerchantOrderPayment merchantOrderPaymentData = merchantOrderPaymentRepository.save(merchantOrderPayment);
        return merchantOrderPaymentMapper.entityToDto(merchantOrderPaymentData);
    }

    /**
     * This Method Is Used To Update MerchantOrderPayment Status.
     */
    public void markMerchantOrderPaymentStatusFail(MarkTransactionFailRequest markTransactionFailRequest) {
        logger.debug(" going to start update merchantOrderPayment status: ");
        String mId = EPayIdentityUtil.getUserPrincipal().getMId();
        MerchantOrderPayment merchantOrderPayment = merchantOrderPaymentRepository.findBymIdAndAtrnNumber(mId, markTransactionFailRequest.getAtrn()).orElseThrow(() -> new TransactionException(TransactionErrorConstants.NOT_FOUND_ERROR_CODE, MessageFormat.format(TransactionErrorConstants.NOT_FOUND_ERROR_MESSAGE, "MerchantOrder Payment")));
        if (StringUtils.isEmpty(merchantOrderPayment.getAtrnNumber()) || PaymentStatus.SUCCESS.equals(merchantOrderPayment.getPaymentStatus()) || PaymentStatus.FAILED.equals(merchantOrderPayment.getPaymentStatus())) {
            throw new TransactionException(TransactionErrorConstants.INVALID_ERROR_CODE, MessageFormat.format(TransactionErrorConstants.INVALID_ERROR_MESSAGE, "Atrn", "Atrn status is already updated  "));
        }
        merchantOrderPayment.setTransactionStatus(TransactionStatus.FAILED);
        merchantOrderPayment.setPaymentStatus(PaymentStatus.FAILED);
        merchantOrderPayment.setFailReason(markTransactionFailRequest.getFailReason());
        merchantOrderPayment = merchantOrderPaymentRepository.save(merchantOrderPayment);
        logger.debug(" Updated merchantOrderPayment status: " + merchantOrderPayment);
        merchantOrderPaymentMapper.entityToDto(merchantOrderPayment);
    }

    public boolean validatedMerchantOrderPaymentForBooking(String sbiOrderRefNumber, List<String> statusList) {
        return merchantOrderPaymentRepository.countBySbiOrderRefNumberAndTransactionStatusIn(sbiOrderRefNumber, statusList) > 0;
    }

    public Object[] cardPaymentSummary(String altHash) {
        logger.info("Fetching data from MerchantOrderPayment and MerchantOrder table.");
        return merchantOrderPaymentRepository.cardPaymentSummary(altHash);
    }

    public MerchantPaymentOrderDto findByAtrnNumber(String atrn) {
        MerchantOrderPayment merchantOrderPayment = merchantOrderPaymentRepository.findByAtrnNumber(atrn).orElseThrow(() -> new TransactionException(TransactionErrorConstants.NOT_FOUND_ERROR_CODE, MessageFormat.format(TransactionErrorConstants.NOT_FOUND_ERROR_MESSAGE, "MerchantOrderPayment detail")));
        return merchantOrderPaymentMapper.entityToDto(merchantOrderPayment);
    }

    public Page<MerchantOrderResponse> findBySpecification(String mId, MerchantOrderPaymentSearchRequest merchantOrderPaymentSearchRequest, Pageable pageable) {
        Specification<MerchantOrderPayment> specification = TransactionSpecification.searchTransaction(mId, merchantOrderPaymentSearchRequest);
        return merchantOrderPaymentRepository.findAll(specification, pageable).map(this::convertEntityToMerchantOrderResponse);
    }

    private MerchantOrderResponse convertEntityToMerchantOrderResponse(MerchantOrderPayment merchantOrderPayment) {
        return merchantOrderPaymentMapper.entityToMerchantOrderResponse(merchantOrderPayment);
    }


}
