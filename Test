package com.sbi.epay.authentication.service;

import com.sbi.epay.authentication.exception.EPaySecurityException;
import com.sbi.epay.authentication.model.AccessTokenRequest;
import com.sbi.epay.authentication.model.EPayPrincipal;
import com.sbi.epay.authentication.model.TransactionTokenRequest;
import com.sbi.epay.authentication.model.UserTokenRequest;
import com.sbi.epay.authentication.util.EPayAuthenticationConstant;
import com.sbi.epay.authentication.util.EPayAuthenticationErrorConstants;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import io.jsonwebtoken.security.SignatureException;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.security.Key;
import java.text.MessageFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import static com.sbi.epay.authentication.util.EPayJwtClaimsSet.*;

/**
 * Class Name: JwtService
 * *
 * Description: Service Class for generating and validating JSON Web Tokens (JWT).
 * * This class provides methods to create signed JWTs using various inputs, including username/pwd, API keys, and hashed values.
 * *
 * Author: V1018217(Nirvay K. Bikram)
 * Copyright (c) 2024 [State Bank of India]
 * All rights reserved
 * *
 * Version:1.0
 */
@Component
@RequiredArgsConstructor
public class JwtService {
    private static final LoggerUtility logger = LoggerFactoryUtility.getLogger(JwtService.class);

    private final AuthenticationUserService authenticationUserService;
    @Value("${security.jwt.secret.key}")
    private String secretKey;
    @Value("${security.jwt.secret.issuer}")
    private String issuer;

    /**
     * Generates a JWT token with the specified claims, username, and expiration time.
     *
     * @param claims         A map of claims to include in the token.
     * @param userName       The username used to sign the token.
     * @param expirationTime The expiration time of the token in milliseconds.
     * @return A signed JWT token as a string.
     */
    private String generateToken(Map<String, Object> claims, String userName, long expirationTime) {
        logger.info("ClassName - JwtService,MethodName - generateToken,generate a JWT token  with the specified claims, username, and expiration time.");
        Claims jwtClaims = Jwts.claims(claims);
        jwtClaims.setSubject(userName);
        jwtClaims.setIssuer(issuer);
        jwtClaims.setIssuedAt(new Date(System.currentTimeMillis()));
        jwtClaims.setExpiration(new Date(expirationTime));
        return Jwts.builder().setClaims(jwtClaims).signWith(getSignKey(), SignatureAlgorithm.HS512).compact();
    }
_________


package com.sbi.epay.authentication.service;

import com.sbi.epay.authentication.exception.EPaySecurityException;
import com.sbi.epay.authentication.model.EPayPrincipal;
import com.sbi.epay.authentication.util.EPayAuthenticationErrorConstants;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;

import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class AuthenticationUserDetailsServiceTest {

    @Mock
    private AuthenticationUserService userService;

    @InjectMocks
    private AuthenticationUserDetailsService authenticationUserDetailsService;

    private static final String TEST_USERNAME = "testUser";

    @BeforeEach
    void setUp() {
        // No need to manually instantiate authenticationUserDetailsService since @InjectMocks handles it.
    }

    @Test
    void testUserDetailsService_Initialization() {
        // Act
        UserDetailsService userDetailsService = authenticationUserDetailsService.userDetailsService();

        // Assert
        assertNotNull(userDetailsService, "UserDetailsService should be initialized");
    }

    @Test
    void testUserDetailsService_UserFound() {
        // Arrange
        EPayPrincipal mockPrincipal = mock(EPayPrincipal.class);
        when(userService.loadUserByUserName(TEST_USERNAME)).thenReturn(Optional.of(mockPrincipal));

        UserDetailsService userDetailsService = authenticationUserDetailsService.userDetailsService();

        // Act
        UserDetails userDetails = userDetailsService.loadUserByUsername(TEST_USERNAME);

        // Assert
        assertNotNull(userDetails, "UserDetails should not be null");
        assertEquals(mockPrincipal, userDetails, "Returned user details should match");
        verify(userService, times(1)).loadUserByUserName(TEST_USERNAME);
    }

    @Test
    void testUserDetailsService_UserNotFound() {
        // Arrange
        when(userService.loadUserByUserName(TEST_USERNAME)).thenReturn(Optional.empty());

        UserDetailsService userDetailsService = authenticationUserDetailsService.userDetailsService();

        // Act & Assert
        EPaySecurityException exception = assertThrows(EPaySecurityException.class, () -> {
            userDetailsService.loadUserByUsername(TEST_USERNAME);
        });

        assertEquals(EPayAuthenticationErrorConstants.NOT_FOUND_ERROR_CODE, exception.getErrorCode(), "Error code should match");
        assertTrue(exception.getMessage().contains(EPayAuthenticationErrorConstants.NOT_FOUND_ERROR_MESSAGE), "Exception message should match");
        verify(userService, times(1)).loadUserByUserName(TEST_USERNAME);
    }

    @Test
    void testUserDetailsService_NullOrEmptyUsername() {
        // Arrange
        UserDetailsService userDetailsService = authenticationUserDetailsService.userDetailsService();

        // Act & Assert
        assertThrows(IllegalArgumentException.class, () -> userDetailsService.loadUserByUsername(null), "Null username should throw IllegalArgumentException");
        assertThrows(IllegalArgumentException.class, () -> userDetailsService.loadUserByUsername(""), "Empty username should throw IllegalArgumentException");
    }
}
