import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import com.sbi.epay.authentication.exception.EPaySecurityException;
import com.sbi.epay.authentication.model.AccessTokenRequest;
import com.sbi.epay.authentication.model.TransactionTokenRequest;
import com.sbi.epay.authentication.model.UserTokenRequest;
import com.sbi.epay.authentication.service.JwtService;
import com.sbi.epay.authentication.service.AuthenticationUserService;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.util.ReflectionTestUtils;

import java.security.Key;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

@ExtendWith(MockitoExtension.class)
class JwtServiceTest {

    @InjectMocks
    private JwtService jwtService;

    @Mock
    private AuthenticationUserService authenticationUserService;

    private String secretKey = "testsecretkey12345678901234567890123456789012"; // 32+ bytes key
    private String issuer = "TestIssuer";

    @BeforeEach
    void setUp() {
        ReflectionTestUtils.setField(jwtService, "secretKey", secretKey);
        ReflectionTestUtils.setField(jwtService, "issuer", issuer);
    }

    @Test
    void generateUserLoginToken_ShouldReturnValidToken() {
        UserTokenRequest userTokenRequest = new UserTokenRequest("testUser", "ROLE_USER", "USER_TYPE", System.currentTimeMillis() + 60000);
        String token = jwtService.generateUserLoginToken(userTokenRequest);
        assertNotNull(token);
    }

    @Test
    void generateAccessToken_ShouldReturnValidToken() {
        AccessTokenRequest accessTokenRequest = new AccessTokenRequest("testUser", "12345", "ROLE_ADMIN", "ACCESS_TYPE", System.currentTimeMillis() + 60000);
        String token = jwtService.generateAccessToken(accessTokenRequest);
        assertNotNull(token);
    }

    @Test
    void generateTransactionToken_ShouldReturnValidToken() {
        TransactionTokenRequest transactionTokenRequest = new TransactionTokenRequest("testOrder", "12345", "testUser", "ROLE_USER", "TXN_TYPE", "ref123", System.currentTimeMillis() + 60000);
        String token = jwtService.generateTransactionToken(transactionTokenRequest);
        assertNotNull(token);
    }

    @Test
    void verifyJwtTokenAndGetClaims_WhenTokenIsValid_ShouldReturnClaims() {
        String token = generateTestToken("testUser", System.currentTimeMillis() + 60000);

        Claims claims = jwtService.verifyJwtTokenAndGetClaims(token);
        assertNotNull(claims);
        assertEquals("testUser", claims.getSubject());
    }

    @Test
    void verifyJwtTokenAndGetClaims_WhenTokenIsExpired_ShouldThrowException() {
        String expiredToken = generateTestToken("testUser", System.currentTimeMillis() - 10000);
        Exception exception = assertThrows(IllegalStateException.class, () -> jwtService.verifyJwtTokenAndGetClaims(expiredToken));
        assertEquals("TOKEN_EXPIRED", exception.getMessage());
    }

    private String generateTestToken(String username, long expirationTime) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("username", username);
        claims.put("role", "ROLE_USER");

        return Jwts.builder()
                .setClaims(claims)
                .setSubject(username)
                .setIssuer(issuer)
                .setIssuedAt(new Date(System.currentTimeMillis()))
                .setExpiration(new Date(expirationTime))
                .signWith(getSignKey())
                .compact();
    }

    private Key getSignKey() {
        byte[] keyBytes = secretKey.getBytes();
        return Keys.hmacShaKeyFor(keyBytes);
    }
}
