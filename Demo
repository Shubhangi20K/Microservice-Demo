
package com.epay.payment.service;

import com.epay.payment.config.InbConfigDeatils;
import com.epay.payment.dao.*;
import com.epay.payment.dto.NbMapWebResponseDto;
import com.epay.payment.dto.TransactionDto;
import com.epay.payment.entity.PostingData;
import com.epay.payment.exceptions.PaymentException;
import com.epay.payment.externalservice.PaymentWebClientService;
import com.epay.payment.model.request.PaymentRequest;
import com.epay.payment.model.response.PaymentResponse;
import com.epay.payment.util.InbEncryptionDecryptionUtil;
import com.epay.payment.util.InbErrorConstants;
import com.epay.payment.util.PaymentConstants;
import com.epay.payment.util.PaymentUtil;
import com.epay.payment.util.enums.PaymentStatus;
import com.epay.payment.validator.PaymentValidator;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.web.servlet.view.RedirectView;
import java.text.MessageFormat;
import java.util.List;
import java.util.Optional;

/**
 * Class Name:NbPaymentService
 * *
 * Description:
 * *
 * Author:VCE2645(Siddhesh Nikam)
 * <p>
 * Copyright (c) 2024 [State Bank of India]
 * All right reserved
 * *
 * Version:1.0
 */

@RequiredArgsConstructor
@Service
public class InbPaymentService {

    LoggerUtility logger = LoggerFactoryUtility.getLogger(this.getClass());
    private final PaymentUtil paymentUtil;
    private final TransactionDao transactionDao;
    private final PaymentDao paymentDao;
    private  final InbEncryptionDecryptionUtil inbEncryptionDecryptionUtil;
    private final PaymentValidator paymentValidator;
    private final InbConfigDeatils inbConfigDeatils;
    private final NbPaymentDao nbPaymentDao;
    private final StatusUpdatePaymentDao statusUpdatePaymentDao;
    private final PaymentWebClientService paymentWebClientService;

    /**
     * @return -JSON : PaymentResponse<PostingData> (1.postURL, 2.data, 3.Key, 4.merchantCode)
     * @methodName: Generate Web Request Payload.
     * @@Method-Description: The purpose of this method is to create web request and encrypt request.
     * @param: generateReqPayload
     * @Exception or @Error :Exception
     */
    public PaymentResponse<PostingData> generateReqPayload(PaymentRequest paymentWebRequest) {
        logger.info("Payment Initiation Start for Atrn {} ", paymentWebRequest.getAtrn());
        TransactionDto transactionDto = transactionDao.getValidPaymentAckReq(paymentWebRequest.getAtrn(), PaymentStatus.BOOKED.toString());
        logger.info("Payment Initiation get atrn details {} ", transactionDto);
        paymentValidator.validateDebitAmount(transactionDto.getDebitAmt());
        String  planeTextWebReqData = paymentUtil.createWebRequest(paymentWebRequest.getAtrn(), transactionDto.getDebitAmt());
        logger.info("Payment Initiation Plane Text Web Request {} , and ATRN {}", planeTextWebReqData,paymentWebRequest.getAtrn());
        paymentDao.saveRequestLog(planeTextWebReqData,paymentWebRequest.getAtrn(), PaymentConstants.WEB_REQUEST_TYPE,PaymentConstants.CREATED_BY);
        PostingData encryptedPostedData = inbEncryptionDecryptionUtil.encryptedPostedData(planeTextWebReqData,paymentWebRequest.getAtrn());
        logger.info("Payment Initiation Encrypted Web Request {} , and ATRN {}", encryptedPostedData.getData(),paymentWebRequest.getAtrn());
        return PaymentResponse.<PostingData>builder().status(1).count(1L).size(1L).data(List.of(encryptedPostedData)).build();
    }

}



package com.epay.payment.dao;

import com.epay.payment.dto.TransactionDto;
import com.epay.payment.entity.MerchantOrderPayments;
import com.epay.payment.exceptions.PaymentException;
import com.epay.payment.mapper.TransactionMapper;
import com.epay.payment.repository.TransactionRepository;
import com.epay.payment.util.ErrorConstants;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import java.text.MessageFormat;

/**
 * Class Name: TransactionDao
 * *
 * Description:
 * *
 * Author: VCE2645(Siddhesh Nikam)
 * Copyright (c) 2024 [State Bank of India]
 * ALl rights reserved
 * *
 * Version: 1.0
 */
@Component
@RequiredArgsConstructor
public class TransactionDao {

    private  final TransactionRepository transactionRepository;
    private final TransactionMapper transactionMapper;

    public TransactionDto getValidPaymentAckReq(String atrn,String paymentStatus) {
        MerchantOrderPayments merchantOrderPayments = transactionRepository.findByAtrnNumAndTransactionStatus(atrn, paymentStatus)
                .orElseThrow(() -> new PaymentException(ErrorConstants.NOT_FOUND_ERROR_CODE, MessageFormat
                        .format(ErrorConstants.NOT_FOUND_ERROR_MESSAGE, "Payment")));
        return transactionMapper.mapToTransactionDto(merchantOrderPayments);
    }

}


package com.epay.payment.util;

import com.epay.payment.config.InbConfigDeatils;
import com.epay.payment.exceptions.PaymentException;
import com.epay.payment.externalservice.PaymentWebClientService;
import com.epay.payment.model.response.PaymentCallBackDvResponse;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import lombok.RequiredArgsConstructor;
import org.apache.commons.lang3.StringUtils;
import org.springframework.stereotype.Component;
import java.math.BigDecimal;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.text.MessageFormat;
import java.util.Arrays;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Class Name:PaymentUtil
 * *
 * Description:
 * *
 * Author:VCE2645(Siddhesh Nikam)
 * <p>
 * Copyright (c) 2024 [State Bank of India]
 * All right reserved
 * *
 * Version:1.0
 */

@Component
@RequiredArgsConstructor
public class PaymentUtil {
    LoggerUtility logger = LoggerFactoryUtility.getLogger(this.getClass());
    private  final InbEncryptionDecryptionUtil inbEncryptionDecryptionUtil;
    private final InbConfigDeatils inbConfigDeatils;
    private final PaymentWebClientService paymentWebClientService;

    /**
     * @return: key, value
     * @methodName: Web and DV Decrypted Data set in map.
     * @@Method-Description: Process DecryptedData and set in map.
     * @param: getDecryptedData
     * @Exception: or @Error :Exception
     */
    public Map<String,String> getDecryptedData(String decResponse) {
        return Arrays.stream(decResponse.split(PaymentConstants.PIPE_CONST))
                .map(kv -> kv.split(PaymentConstants.PATTERN_EQUAL_TO_CONST))
                .filter(kvArray -> kvArray.length == 2)
                .collect(Collectors.toMap(kv -> kv[0], kv ->StringUtils.isBlank(kv[1])?PaymentConstants.NA:kv[1]));
    }

    /**
     * @return: webRequestData and Checksum
     * @methodName: Create Web Request for SBI Bank.
     * @@Method-Description: Process Create Web Request and checksum.
     * @param: createEncrptedWebReq
     * @Exception: or @Error :Exception
     */
    public String createWebRequest(String atrn, BigDecimal amountFromDB) {

        StringBuilder webReqData = new StringBuilder();
        webReqData.append(MessageFormat.format(PaymentConstants.SBIINB_WEB_REQUEST,atrn,amountFromDB, inbConfigDeatils.getCancelUrl(), inbConfigDeatils.getSbiRedirectUrl()));
        String checkSum = inbEncryptionDecryptionUtil.getSHA2Checksum(webReqData.toString());
        logger.info("Payment Initiation Web Request {} ,and checkSum{} , and ATRN {} for SBI INB : ", webReqData,checkSum,atrn);
        return   Optional.of(webReqData.toString()
                        .concat(PaymentConstants.SBIINB_CHECKSUM)
                        .concat(checkSum)).filter(x->!x.isEmpty())
                .orElseThrow(() ->new PaymentException(ErrorConstants.ENCRYPTION_WEB_REQ_ERROR_CODE, ErrorConstants.ENCRYPTION_WEB_REQ_ERROR_MESSAGE));
    }

    /**
     * @return: DV Response from bank.
     * @methodName: Process DV Request.
     * @@Method-Description: Process DV Request.
     * @param: processingDoubleVerRequest
     * @Exception: or @Error :Exception
     */
   
    public PaymentCallBackDvResponse processingDoubleVerRequest(String PlainDVRequestAndChecksum){

        try {
            String encryptedDVData = Optional.ofNullable(URLEncoder.encode(inbEncryptionDecryptionUtil.encrypt(PlainDVRequestAndChecksum), PaymentConstants.UTF_EIGHT)).filter(x -> !x.isEmpty()).orElseThrow(() -> new PaymentException(InbErrorConstants.ENCRYPTION_ERROR_CODE, InbErrorConstants.ENCRYPTION_ERROR_MESSAGE));
            logger.info("Payment Callback Encrypted and Encoded Double Verification {} " + encryptedDVData);

            String DVResponse = Optional.ofNullable(paymentWebClientService
                            .SBIDVResponseConn(inbConfigDeatils.getSbiNburl(), (PaymentConstants.SBIINB_MERCH_CODE_CONST)
                                    .concat(PaymentConstants.SBIINB_MERCH_CODE_VAL)
                                    .concat(PaymentConstants.SBIINB_ENC_DATA).concat(encryptedDVData)))
                    .filter(x -> !x.isEmpty()).orElseThrow(() -> new PaymentException(InbErrorConstants.DOUBLE_VERIFICATION_ERROR_CODE, InbErrorConstants.DOUBLE_VERIFICATION_ERROR_MESSAGE));
            logger.info("Payment Callback Encrypted Double Verification Response {} ", DVResponse);

            String decryptedDVResponse = URLDecoder.decode(inbEncryptionDecryptionUtil.decrypt(DVResponse.trim().replaceAll(PaymentConstants.NEW_LINE_REGEX, PaymentConstants.PATTERN_EMPTY).replace(PaymentConstants.PATTERN_SPACE, PaymentConstants.PATTERN_EMPTY)), StandardCharsets.UTF_8);
            logger.info("Payment Callback Decrypted and Decode Double Verification Response {} ", decryptedDVResponse);

            return PaymentCallBackDvResponse.builder().paymentResponse(decryptedDVResponse).build();
        } catch (Exception e) { // Exception throw by INB Bank Algorithm
            logger.error("Exception While processingDoubleVerRequest  {}", e);
            throw new PaymentException(InbErrorConstants.INVALID_ERROR_CODE, MessageFormat.format(InbErrorConstants.INVALID_ERROR_MESSAGE, PaymentConstants.INVALIDHASHVALUE));
        }
    }
}

package com.epay.payment.util;

import com.epay.payment.config.InbConfigDeatils;
import com.epay.payment.entity.PostingData;
import com.epay.payment.exceptions.PaymentException;
import com.sbi.epay.logging.utility.LoggerFactoryUtility;
import com.sbi.epay.logging.utility.LoggerUtility;
import lombok.RequiredArgsConstructor;
import org.apache.commons.codec.binary.Base64;
import org.springframework.core.io.ClassPathResource;
import org.springframework.stereotype.Component;

import javax.crypto.Cipher;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.text.MessageFormat;
import java.util.Arrays;

/**
 * Class Name:NbEncryptionDecryptionUtil
 * *
 * Description:
 * *
 * Author:VCE2645(Siddhesh Nikam)
 * <p>
 * Copyright (c) 2024 [State Bank of India]
 * All right reserved
 * *
 * Version:1.0
 */

@Component
@RequiredArgsConstructor
public class InbEncryptionDecryptionUtil {

    private final InbConfigDeatils inbConfigDeatils;
    private static final LoggerUtility logger = LoggerFactoryUtility.getLogger(InbEncryptionDecryptionUtil.class);
   
    public PostingData encryptedPostedData(String plainWebRequestAndChecksum, String atrn) {
        String encWebReqData= encrypt(plainWebRequestAndChecksum);
        return PostingData.builder()
                .postURL(inbConfigDeatils.getBankBrowserURL())
                .data(encWebReqData)
                .key(inbConfigDeatils.getKeyValue())
                .merchantCode(inbConfigDeatils.getMerchantCode())
                .atrn(atrn)
                .build();
    }

   
    public String getSHA2Checksum(String data) {
        MessageDigest md;
        StringBuffer hexString = new StringBuffer();
        try{
            md = MessageDigest.getInstance("SHA-256");
            md.update(data.getBytes());
            byte byteData[] = md.digest();
            StringBuffer sb = new StringBuffer();
            for (int i = 0; i < byteData.length; i++) {
                sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));
            }
            for (int i = 0; i < byteData.length; i++) {
                String hex = Integer.toHexString(0xff & byteData[i]);
                if (hex.length() == 1) hexString.append('0');
                hexString.append(hex);
            }
        return hexString.toString();
        } catch (Exception e) { // Exception throw by INB Bank Algorithm
            logger.error("Exception While Decrypt  {} {}", e.getCause(),e.getMessage());
            throw new PaymentException(InbErrorConstants.INVALID_ERROR_CODE, MessageFormat.format(InbErrorConstants.INVALID_ERROR_MESSAGE, PaymentConstants.INVALIDHASHVALUE));
        }
    }

   
    public String encrypt(String data)
    {
        ClassPathResource path = new ClassPathResource(PaymentConstants.SBIINB_KEY_PATH);
        byte[] key;
        try{
        key = returnByte(path.getInputStream());

        String encData;

            Cipher cipher = Cipher.getInstance(PaymentConstants.SBIINB_AES_GCM_NOPADDING);
            int blockSize = cipher.getBlockSize();
            byte[] iv = new byte[cipher.getBlockSize()];
            byte[] dataBytes = data.getBytes();
            int plaintextLength = dataBytes.length;
            int remainder = plaintextLength % blockSize;
            if (remainder != 0) {
                plaintextLength += blockSize - remainder;
            }
            byte[] plaintext = new byte[plaintextLength];
            System.arraycopy(dataBytes, 0, plaintext, 0, dataBytes.length);
            SecretKeySpec keySpec = new SecretKeySpec(key, PaymentConstants.AES_ALGO);
            SecureRandom randomSecureRandom = SecureRandom.getInstance(PaymentConstants.SHA1PRNG);
            randomSecureRandom.nextBytes(iv);
            GCMParameterSpec parameterSpec = new GCMParameterSpec(128, iv);
            cipher.init(1, keySpec, parameterSpec);
            byte[] results = cipher.doFinal(plaintext);
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            outputStream.write(iv);
            outputStream.write(results);
            byte[] encryptedData = outputStream.toByteArray();
            encData = Base64.encodeBase64String(encryptedData);
            encData = encData.replace("\n", "").replace("\r", "");
            encData = encData.replaceAll("\r\n", "");
            encData = encData.replaceAll("\r", "");
            encData = encData.replaceAll("\n", "");
            encData = encData.replaceAll(" ", "");

        return encData;
        } catch (Exception e) { // Exception throw by INB Bank Algorithm
            logger.error("Exception While Decrypt  {} {}", e.getCause(),e.getMessage());
            throw new PaymentException(InbErrorConstants.INVALID_ERROR_CODE, MessageFormat.format(InbErrorConstants.INVALID_ERROR_MESSAGE, PaymentConstants.INVALIDHASHVALUE));
        }
    }

   
    public String decrypt(String encData) {
        String decdata;
        try{
            ClassPathResource path = new ClassPathResource(PaymentConstants.SBIINB_KEY_PATH);
            byte[] key = returnByte(path.getInputStream());

            Cipher cipher = Cipher.getInstance(PaymentConstants.SBIINB_AES_GCM_NOPADDING);
            SecretKeySpec keySpec = new SecretKeySpec(key, "AES");
            byte[] results = Base64.decodeBase64(encData);
            byte[] iv = Arrays.copyOfRange(results, 0, cipher.getBlockSize());
            cipher.init(2, keySpec, new GCMParameterSpec(128, iv));
            byte[] results1 = Arrays.copyOfRange(results, cipher.getBlockSize(), results.length);
            byte[] ciphertext = cipher.doFinal(results1);
            decdata = new String(ciphertext, StandardCharsets.UTF_8).trim();

        return decdata;
        } catch (Exception e) { // Exception throw by INB Bank Algorithm
            logger.error("Exception While Decrypt  {} {}", e.getCause(),e.getMessage());
            throw new PaymentException(InbErrorConstants.INVALID_ERROR_CODE, MessageFormat.format(InbErrorConstants.INVALID_ERROR_MESSAGE, PaymentConstants.INVALIDHASHVALUE));
        }
    }

   
    private static byte[] returnByte(InputStream inputData) {
        try{
        return inputData.readAllBytes();
        } catch (Exception e) { // Exception throw by INB Bank Algorithm
            logger.error("Exception While Decrypt  {} {}", e.getCause(),e.getMessage());
            throw new PaymentException(InbErrorConstants.INVALID_ERROR_CODE, MessageFormat.format(InbErrorConstants.INVALID_ERROR_MESSAGE, PaymentConstants.INVALIDHASHVALUE));
        }
    }
}
